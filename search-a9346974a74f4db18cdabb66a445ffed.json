[{"title":"Java 8 的变化之行为参数化——Lambda 表达式","url":"/posts/6340/","content":"\n## 什么是行为参数化\n\n假设现在有两个需求，分别是打印如下所示的加法表和乘法表：\n\n``` bash\n1 + 1 = 2\n1 + 2 = 3\t2 + 2 = 4\n1 + 3 = 4\t2 + 3 = 5\t3 + 3 = 6\n1 + 4 = 5\t2 + 4 = 6\t3 + 4 = 7\t4 + 4 = 8\n......\n\n----------------------------\n\n1 * 1 = 1\n1 * 2 = 2\t2 * 2 = 4\n1 * 3 = 3\t2 * 3 = 6\t3 * 3 = 9\n1 * 4 = 4\t2 * 4 = 8\t3 * 4 = 12\t4 * 4 = 16\n......\n\n```\n\n在这两个运算表中，需要展示的格式是一样的，不同的地方有两点：\n\n- 运算符\n- 运算逻辑\n\n如果只使用一个方法来生成这样两个运算表格，则需要将运算符和运算逻辑都作为参数传递这个方法。其中运算符可以视为一个字符串，是一种几乎所有编程语言都内置原生支持的一种类型。但是运算逻辑则不同，只有将函数视为头等公民的编程语言才能将行为即函数作为实参进行传递。\n\n#### 函数作为头等公民\n\n在一些程序语言中，函数视为头等公民，这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。使用函数作为实参和返回值的函数被称为高阶函数。更多可以信息可以参考[头等函数-维基百科](https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0)。\n\nJavaScript是一种内置将函数视为头等公民的语言，如果用JavaScript来实现上述打印加法表和乘法表的需求，只需要将乘法与加法定义为变量再作为实参传递给生成表的函数就行了，完整代码如下所示：\n\n``` javascript\nconst multiplication = (a, b) => a * b;\nconst addition = (a, b) => a + b;\n\nconst generateOperationTable = (limit, operationSymbol, operation) => {\n    let result = '';\n    for (let i = 1; i <= limit; i++) {\n        let lineResult = '';\n        for (let j = 1; j <= i; j++) {\n            lineResult += `${j} ${operationSymbol} ${i} = ${operation(i, j)}\\t`;\n        }\n        result += lineResult + '\\n';\n    }\n    return result;\n}\n\nconst multiplicationTable = generateOperationTable(9, '*', multiplication);\nconst additionTable = generateOperationTable(9, '+', addition);\n\nconsole.log(multiplicationTable);\nconsole.log(additionTable);\n\n```\n\n行为参数化，就是一个方法接受多个不同的行为作为参数，并且在内部使用它们，完成不同的行为。\n\n## 为什么要进行行为参数化\n\n从上面的例子中可以看出，将行为即函数视为一个普通变量后，可以提高抽象能力，\n减少重复代码，使代码的表达能力更强，也更易于理解。\n\n以下对比将展现更多行为参数在Java中体现出来的好处。\n\n## Java 8中如何实现行为参数化\n\n### Java 8之前的Java如何将行为传递给方法\n\nJava是一门**面向对象**的、**静态类型**语言，所以在将行为传递给一个方法前，这个行为必定有着特定的类型，而且为一个实例。于是有以下不同的方式来实现效果。\n\n#### 通过实现不同的接口\n\n在生成运算表的方法中，可以同时传入加法与乘法两种运算操作，所以这两种操作必须为同一类型。于是有了`Arithmetic`接口：\n\n```java\npublic interface Arithmetic {\n    public int calculate(int a, int b);\n}\n\n```\n\n通过对`Arithmetic`接口的不同实现，可以将加法与乘法两种行为包裹在不同的类中：\n\n```java\npublic class Addition implements Arithmetic {\n    @Override\n    public int calculate(int a, int b) {\n        return a + b;\n    }\n}\n\n```\n\n```java\npublic class Multiplication implements Arithmetic {\n    @Override\n    public int calculate(int a, int b) {\n        return a * b;\n    }\n}\n\n```\n\n在生成操作表的方法中，即可以传入不同`Arithmetic`类型的实例来实现将行为传递进方法内部。\n\n```java\nprivate static void printOperationTableByImplInterface() {\n    String additionTable = genOperationTable(9, \"+\", new Addition());\n    String multiplicationTable = genOperationTable(9, \"+\", new Multiplication());\n\n    System.out.print(additionTable);\n    System.out.print(multiplicationTable);\n}\n\n```\n\n这是生成运算表的方法本身：\n\n```java\nprivate static String genOperationTable(\n            int limit, String operationSymbol, Arithmetic operation) {\n    StringBuilder result = new StringBuilder();\n    for (int i = 1; i <= limit; i++) {\n        String rowResult = \"\";\n        for (int j = 1; j <= i; j++) {\n            int answer = operation.calculate(i, j);\n            rowResult += String.format(\"%d %s %d = %d\\t\", j, operationSymbol, i, answer);\n        }\n        result.append(rowResult).append(\"\\n\");\n    }\n    return result.toString();\n}\n\n```\n\n#### 通过匿名内部类\n\n上述方式中，需要实现声明一个类，然后再实例化。但是在Java中，可以通过匿名内部类来同时声明和实例化一个类，可以稍微简化一下代码：\n\n```java\nprivate static void printOperationTableByInnerClass() {\n    String additionTable =\n            genOperationTable(\n                    9,\n                    \"+\",\n                    new Arithmetic() {\n                        @Override\n                        public int calculate(int a, int b) {\n                            return a + b;\n                        }\n                    });\n\n    String multiplicationTable =\n            genOperationTable(\n                    9,\n                    \"+\",\n                    new Arithmetic() {\n                        @Override\n                        public int calculate(int a, int b) {\n                            return a * b;\n                        }\n                    });\n\n    System.out.print(additionTable);\n    System.out.print(multiplicationTable);\n}\n\n```\n\n### Java 8的实现方式\n\nJava 8中引入Lambda表达式（匿名函数），其可以看作是单纯的一个行为，只需将其传递给方法体，则可直接实现行为参数化。相比于Java 8之前的Java版本，使用Lambda表达式可以极大程度地精简代码。\n\n```java\nprivate static void printOperationTableByLambda() {\n    String additionTable = genOperationTable(9, \"+\", (a, b) -> a + b);\n    String multiplicationTable = genOperationTable(9, \"+\", (a, b) -> a * b);\n\n    System.out.print(additionTable);\n    System.out.print(multiplicationTable);\n}\n```\n\n## 什么是Lambda表达式\n\nLambda表达式是匿名函数的一种表现形式，具有以下几个特点：\n\n- 匿名：可以不像普通方法一样具有一个明确的名称\n- 函数：不像普通方法一样属于某个特定的类，但是和方法类似，其也具有参数列表、函数主体、返回类型，还有可能抛出特定的异常。\n- 传递：可以像参数一样传递给方法或者是储存在变量中\n\n#### Lambda表达式的语法\n\n一个普通的Lambda表达式应当包括：\n\n- 参数列表：\n    * 用`()`包裹起来\n    * 可以不显示指定参数的类型\n    * 只有一个参数时可以省略`()`\n- 箭头：`->`，将参数列表和函数主体相分割开来\n- 函数主体：\n    * 函数主体只有一句时可以省略显式的`return`语句，默认将会运算后的值作为返回值\n    * 函数主体有多句时，需要使用`{}`将函数主体包裹起来，且显式的指定`return`语句\n\nLambda表达式并没有破坏Java原有设计，Java 8同样还是一门**面向对象**的、**静态类型**语言。实际上，Lambda表达式以内联的形式为一种称为**函数式接口**的特殊接口中的**抽象方法**提供了实现，并且将整个表达式作为该函数式接口的一个**具体实现**的**实例**。\n\nLambda表达式可以被赋给一个变量，或者传递给一个接受函数式接口作为参数的方法中，当然Lambda表达式的签名需要和函数式接口的抽象方法一样。\n\n## 函数式接口\n\n函数式接口是一种只定义了**一个抽象方法**的特殊接口。像上述的`Arithmetic`接口，就是一个函数式接口。\n\n在函数式接口上可以使用`@FunctionalInterface`注解来显式表明此接口为一个函数式接口，如果加了注解但却不满足函数式接口的定义，编译器将会返回一个错误。\n\n值得注意的是，在Java 8中，接口可以拥有默认方法，即实现类没有实现该方法时，将会有默认的实现。即在Java 8中，接口可以有完整的方法体。即便接口有多个默认方法，只要其只有一个抽象方法，其仍然为函数式接口。\n\n### 常见的内置函数式接口\n\n以下表格总结了常见的Java 8中内置的函数式接口：\n\n| 函数式接口            | 函数描述符         | 抽象方法名称   |\n|---------------------|-------------------|--------------|\n| Predicate<T>        | T -> boolean      | test         |\n| Consumer<T>         | T -> void         | accept       |\n| Supplier<T>         | () -> T           | get          |\n| Function<T, R>      | T -> R            | apply        |\n| UnaryOperator<T>    | T -> T            | apply        |\n| BinaryOperator<T>   | (T,T) -> T        | apply        |\n| BiPredicate<L, R>   | (L, R) -> boolean | test         |\n| BiConsumer<T, U>    | () -> void        | accept       |\n| BiFunction<T, U, R> | (T,U) -> R        | apply        |\n\n函数描述符描述了这些函数式接口实例的签名，使用这些函数式接口的实例需要使用其对应的抽象方法。\n\n例如：\n\n- `Predicate<String> isLongThanFive = s -> s.length() > 5;`\n- `isLongerThanFice.test(sampleString)`\n- `Consumer<String> print = (String s) -> System.out.println(s);`\n- `print.accept(sampleString)`\n- `BiFunction<Integer, Integer, Integer> sum = (Integer a, Integer b) -> a + b;`\n- `sum.apply(a, b)`\n\n由于Lambda表达式还是遵循了Java原有的设计思想，所以内置的函数式接口还是有一些局限性，比如无法使用两个以上的参数作为Lambda表达式的入参，此时可以使用自定义函数式接口，或者使用第三方的包。\n\n#### 原始类型特化\n\n内置函数式接口中的泛型只能绑定到引用类型上，但是在使用时经常会使用基本类型，此时Java内部会自动进行装箱和拆箱操作，将基本类型与对应的引用类型进行相互转换。但拆装箱操作也会带来额外的性能消耗，所以Java 8还内置了一些原始类型特化的函数式接口来在输入与输出的时候避免拆装箱操作。\n\n一般来说，针对输入类型为基本类型的函数式接口的名称前都要加上对应的基本类型前缀，如`IntPredicate`、`DoubleConsumer`、`Function`接口还有针对输出参数类型的变种：`ToIntFunction<T>`、`IntToDoubleFunction`等等。\n\n例如：\n\n- `IntPredicate isLargeThanFive = i -> i > 5;`\n\n## Lambda表达式的类型\n\n### Lambda表达式的类型检查\n\nLambda表达式的**实际类型**是从使用Lambda表达式的上下文中所推断出来的。上下文（比如，接受它传递的方法的参数，或接受它的值的全局变量）中Lambda表达式需要的类型被称为**目标类型**。\n\n可以从赋值的上下文、方法调用的上下文（参数和返回值）以及类型转换的上下文中获得Lambda表达式的目标类型。\n\n只要Lambda表达式的参数类型能够符合目标类型中抽象方法的参数定义，也就是方法签名能够兼容，那么此类型检查就能通过，该Lambda表达式也就能应用于此上下文中。\n\n有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口相联系起来，同一个Lambda表达式可以用于多个不同的函数式接口中的上下文中，即使这些函数式接口并没有`is`或`like`等关系。\n\n所以上例中加法和乘法的Lambda表达式既可以是一个`Arithmetic`类型，也可以是一个`BiFunction`类型，实际类型需要根据上下文而定。\n\n#### 特殊的`void`兼容规则\n\n如果Lambda表达式的主体是一个语句，在参数列表兼容的前提下，即便其有特定的返回值，其也和返回`void`的函数描述符兼容。\n\n例如，List添加元素后会返回一个布尔值，但是其也可以被`Consumer`类型的函数式接口所接受。\n\n```java\nList<String> strings = new ArrayList<>();\nPredicate<String> adder = s -> strings.add(s);\nConsumer<String> anotherAdder = s -> strings.add(s);\n\n```\n\n### 推断Lambda表达式参数的类型\n\nJava编译器能够从上下文（目标类型）中推断出用什么函数式接口来配合Lambda表达式，所以其也能推断出Lambda表达式的参数类型，可以在Lambda表达式语法中省略参数类型标注。\n\n### Lambda表达式使用局部变量\n\nLambda表达式可以在主体中使用类中的静态变量和实例变量，但是使用方法内的局部变量时，该局部变量必须显示的声明为`final`类型，或者事实上为`final`类型（声明后没有被重新赋值）。\n\n## 组合Lambda表达式\n\n可以将多个简单的Lambda表达式组合成复杂的表达式，比如可以将多个`Predicate`的结果进行布尔运算，组合成一个更大的`Predicate`。\n\n函数式接口中的默认方法为这种组合提供了实现。\n\n### `Comparator`组合Lambda表达式\n\n- `.reversed()`：逆序\n- `.thenComparing()`：第一个比较参数相同时，继续进行比较\n\n### `Predicate`组合Lambda表达式\n\n- `.negate()`：非\n- `.and()`：与\n- `.or()`：或\n\n### `Function`组合Lambda表达式\n\n- `.andThen()`：返回一个函数，先执行一个函数，再将结果应用另一个函数\n- `.compose()`：返回一个函数，先执行另一个函数，再将结果应用此函数\n\n例如:`h = f.andThen(g)` == `g(f(x))`，而`h = f.compose(g)` == `f(g(x))`\n\n## 方法引用\n\n使用方法引用可以将现有方法像Lambda表达式一样进行传递，使得代码更自然和易读。\n\n### 方法引用的语法\n\n目标引用放在`::`之前，方法的名称放在后面。例如`Integer::sum`，就是调用了`Integer`类中的静态方法`sum`。\n\n### 方法引用类型\n\n- 静态方法引用：例如`Integer::parseInt`、`Consumer<String> print = System.out::println;`\n- 使用类型实例本身的实例方法引用：例如获得某个`String`类型实例的长度，`String::length`\n- 使用其他类型实例的实例方法引用：例如调用一个已经存在的外部对象中的方法，`expr::instanceMethod`\n- 构造函数引用：与静态方法引用类似，使用`ClassName::new`来使用构造函数引用，如果构造函数参数个数超过两个，可以使用指定义的函数式接口来作为构造函数引用的类型\n","tags":["Java","编程"]},{"title":"VPS 系统重装后要做的事","url":"/posts/27311/","content":"\n## BBR 加速脚本\n\n```bash\nwget -N --no-check-certificate \"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh\" && chmod +x tcp.sh && ./tcp.sh\n```\n\n## 设置 Python3 为默认版本\n\n```bash\nupdate-alternatives --install /usr/bin/python python /usr/bin/python2 1\nupdate-alternatives --install /usr/bin/python python /usr/bin/python3 2\n```\n\n## 扩大搬瓦工的 Swap 空间\n\n```bash\n## 定位到根目录\ncd ~/..\n\n## 删除原有的Swap空间\nrm swap\nrm swapfile\n\n## 创建并格式化新的Swap空间\ndd if=/dev/zero of=/swapfile bs=1M count=1024\nmkswap /swapfile\n\n## 启动新的Swap空间\nswapon /swapfile\n```\n\n## 安装 Pi-hole\n\n```bash\ncurl -sSL https://install.pi-hole.net | bash\n```\n\n\n## 安装V2Ray一键脚本\n\nbash <(curl -s -L https://raw.githubusercontent.com/233boy/v2ray/master/install.sh)\n\n选择websocket+TSL\n\n要是脚本失效了 github上还有备份（切换分支即可见）\n\n\n- [如何在 Ubuntu 20.04 上设置或者修改时区](https://zhuanlan.zhihu.com/p/)138831041\n- [v2ray-agent](https://github.com/mack-a/v2ray-agent)"},{"title":"MySQL 规范","url":"/posts/37646/","content":"\n## 通用规范\n\n- 灵活使用缩进和空格增强可读性\n- 尽量使用标准的 SQL 函数而不是特定的实现以增强可移植性\n- 必要时加入注释，行注释以`--`开头，块注释以`/*·····*/`标记\n- 尽量使用 BETWEEN 而不是多个 AND 语句\n- 尽量使用 IN()而不是多个 OR 语句\n\n## 命名规范\n\n- SQL 大小写不敏感\n- 关键词推荐大写\n- 库、表、字段名称推荐全小写，用下划线即`_`分隔开\n- 列名尽量为单数\n- 表主键统一命名为 id，类型统一为 char(32)\n- 表外键建议命名为`主表名_字段名`\n- 布尔型字段命名加前缀`is`\n- 表示日期时间的字段，都要有后缀，如果只精确到天则以`date`为后缀，如果要精确到时分秒那就用`time`作后缀\n- 表应当尽量与列避免同名\n- 使用有意义的后缀名，比如：\\_id、\\_status、\\_total、\\_num、\\_name、\\_seq、\\_date、\\_tally、\\_size、\\_addr\n\n## 参考：\n\n[数据库设计中的命名规范](https://www.jianshu.com/p/7e60dbd59138)\n[SQL 样式指南 · SQL Style Guide](https://www.sqlstyle.guide/zh/)\n"},{"title":"MySQL 中的事务","url":"/posts/21282/","content":"\n## 事务的概念\n\n数据库事务是指单个逻辑工作单元执行的一系列操作，要么完全执行要么完全不执行。\n\n### 事务的 ACID 四个特性\n\n- 原子性：事务包含的操作要么全部成功，要么全部失败，不会存在部分成功。\n- 一致性：事务执行前后数据库都会处于一致的状态，即没有破坏数据库的完整性约束。\n- 隔离性：数据库进行事务并发操作时，多个事务之间相互隔离，不会有所干扰。\n- 持久性：事务一旦被提交之后，将会对数据库中的数据产生永久性的影响，即使数据库出现故障也不会丢失。\n\n## 事务的操作命令\n\n- BEGIN/START TRANSACTION：开启一个事务\n- COMMIT/COMMIT WORK：提交事务，使得对数据库的修改成为永久性的\n- ROLLBACK/ROLLBACK WORK：恢复到上个 COMMIT 或保存点的状态\n- SAVEPOINT savepoint_name：设置保存点，保存点将在事务处理完成（执行一条 ROLLBACK 或 COMMIT）后自动释放\n- RELEASE SAVEPOINT savepoint_name：删除特定的保存点\n- ROLLBACK TO savepoint_name：回滚到特定的保存点\n- SET TRANSACTION：用来设置事务的隔离级别\n\n## 参考\n\n- [理解事务 - MySQL 事务处理机制](https://www.jianshu.com/p/bcc614524024)\n- [『浅入深出』MySQL 中事务的实现](https://draveness.me/mysql-transaction)\n- [菜鸟学院 - MySQL 事务](https://www.runoob.com/mysql/mysql-transaction.html)\n- [极客学院 - SQL 事务](https://wiki.jikexueyuan.com/project/sql/transactions.html)\n"},{"title":"SQL 索引介绍","url":"/posts/10973/","content":"\n索引（Index）是一种帮助 MySQL 高效获取数据的数据结构。\n\n## 索引类型\n\n- 普通索引：最基本的索引类型，没有唯一性的限制\n- UNIQUE 索引：唯一索引，被索引的字段不能出现重复\n- PRIMARY KEY 索引：主键索引，是唯一索引的一种，但每张表中只能出现一个主键索引\n\n## 编辑索引\n\n### 创建索引\n\n1. 创建表时创建索引：\n\n   - INDEX [index_name](<column_name(length)>)\n   - UNIQUE [index_name](<column_name(length)>)\n   - PRIMARY KEY (column_name(length))\n\n2. ALTER TABLE 修改表来创建索引：\n\n   - ALTER TABLE table_name ADD INDEX index_name (column_list)\n   - ALTER TABLE table_name ADD UNIQUE (column_list)\n   - ALTER TABLE table_name ADD PRIMARY KEY (column_list)\n\n3. 直接创建索引，此方法不可创建主键索引\n   - CREATE INDEX index_name ON table_name (column_list)\n   - CREATE UNIQUE INDEX index_name ON table_name (column_list)\n\n### 删除索引\n\n可利用 ALTER TABLE 或 DROP INDEX 语句来删除索引\n\n- DROP INDEX index_name ON talbe_name\n- ALTER TABLE table_name DROP INDEX index_name\n- ALTER TABLE table_name DROP PRIMARY KEY\n\n### 查看索引\n\n- SHOW INDEX FROM table_names\n- SHOW KEYS FROM table_name\n\n## 选择索引时注意事项\n\n1. 较频繁的作为查询条件的字段应该创建索引以增加查询性能\n2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\n   > 唯一性指不重复的索引值与表记录数的比值，唯一性差则选择的效率低\n3. 更新非常频繁的字段不适合创建索引\n   > 更新字段时同时还会更新索引，如果字段更新过于频繁，将会带来过多的额外性能和空间消耗\n4. 不会出现在 WHERE 子句中的字段不该创建索引\n\n## 参考\n\n- [MYSQL-索引](https://segmentfault.com/a/1190000003072424)\n- [索引的利弊与如何判定，是否需要索引](http://book.51cto.com/art/200906/132452.htm)\n"},{"title":"SQL 中的子查询、联结查询和组合查询","url":"/posts/29495/","content":"\n## 子查询\n\n子查询即嵌套在其他查询中的查询。一般有两种用法，一种是在`WHERE`字句中使用其来限定范围，达到过滤的效果，一般可与`IN`搭配使用。另一种用法作为计算字段使用子查询，即在`SELECT`语句中使用子查询，将子查询的结果作为一列的结果。如下例所示：\n\n```sql\nSELECT AVG(score) AS average_score,\n       (SELECT AVG(score)\n        FROM score\n                 INNER JOIN subject ON score.subject_id = subject.id\n        WHERE subject.subject = \"语文\") AS average_chinese_score\nFROM score;\n```\n\n子查询的缺点在于过多的子查询将会影响性能，而且将导致代码可读性不佳。\n\n## 联合查询\n\n联合查询通常用于需要查看的数据来自多张表，使用`JOIN`语句将多张表连接起来，使用`ON`语句将两张表中相关联的列连接起来。\n\n常用的联合查询包括内连接和外连接。内连接也被称为等值连接，只有同时存在两张表中的记录才会被保留。外连接中两张的表的记录都会被保留，能匹配上的则正确匹配，不能匹配上的将会被设置成`NULL`。外连接分为左连接和右连接，左连接中`JOIN`语句左边的表中的记录将会被保留，右连接则反之。\n\n## 组合查询\n\n组合查询通常用来将两个或者两个以上具有相同结构的列、表达式或者聚集函数的查询结果组合到一起，默认会排除重复值。使用关键词`UNION`。只能在最后使用一次`ORDER BY`语句对结果进行排序。\n\n可以认为，组合查询是将查询结果在行方向上进行拼接，而联合查询是将不同的表在列方向上进行拼接后再进行查询。\n"},{"title":"SQL 中的字符串处理函数和时间处理函数","url":"/posts/54670/","content":"\n## SQL 中字符串处理函数\n\n### 字符串裁剪\n\n- LEFT(str,len)：返回最左边的 len 个长的字符\n- RIGHT(str,len)：返回最左边的 len 个长的字符\n- LTRIM(str)：裁剪字符串左边的空格\n- RTRIM(str)：裁剪字符串右边的空格\n- TRIM(str)：裁剪字符串两边的空格\n- SUBSTRING(str,pos,len)/SUBSTR(str,pos,len)/SUBSTRING(str FROM pos FOR len)：在 str 中，从 pos 位置截取出 len 长的字符串\n\n### 字符串拼接\n\n- CONCAT(str1,str2,...)：拼接多个字符串\n- CONCAT_WS(separator,str1,str2,...)：用分隔符拼接多个字符串\n\n### 字符串转换\n\n- LOWER(str)：将字符串转换为全小写\n- UPPER(str)：将字符串转换为全大写\n- REVERSE(str)：将字符串翻转\n\n### 获取字符串属性\n\n- LENGTH(str)：获取字符串长度\n\n## SQL 中时间处理函数\n\n### 获取当前时间\n\n- NOW():获取当前日期和时间\n- CURDATE():获取当前日期\n- CURTIME():获取当前时间\n\n### 提取时间\n\n- DAY(date)/DAYOFYEAR(date):提取出日期格式的日期数\n- DAYNAME(date)：提取出日期格式中的星期几\n- DAYOFYEAR(date)：提取出日期格式在一年中的天数\n- EXTRACT(unit FROM date)：按照指定格式提取出时间\n\n  ```sql\n  mysql> SELECT EXTRACT(YEAR_MONTH FROM '2019-07-02 01:02:03');\n        -> 201907\n  ```\n\n- HOUR(date): 提取出小时数\n- TIME(expr)：提取出时间\n\n### 编辑时间\n\n- DATE_ADD(date,INTERVAL expr unit)：在日期上增加一段时间\n\n```sql\nSELECT DATE_SUB('2018-05-01',INTERVAL 1 YEAR)\n```\n\n- DATE_SUB(date,INTERVAL expr unit)：在日期上减去一段时间\n- DATEDIFF(expr1,expr2)：expr1-expr2 的值，只有日期部分被计算\n- TIMEDIFF(expr1,expr2)\n"},{"title":"MySQL 中的 JSON Data Type","url":"/posts/48363/","content":"\n## CHAR 与 VARCHAR 的区别\n\n### 长度上\n\n- CHAR 类型使用固定长度进行存储，范围为 0~255，多余长度空间会被以空格补齐，检索是尾部空格会被去除\n- VARCHAR 类型保存可变的长度字符串，范围为 0~65535，除了实际的长度外，还有一个或两个额外的字节来标识字符串长度，\n\n### 应用上\n\n- CHAR 经常用于保存长度相对固定的值，比如 IP 地址或者 MD5 之类的数据。\n- VARCHAR 用来保存保存长短不一的列\n\n### 参考\n\n[MySQL 字符数据类型 char 与 varchar 的区别](http://seanlook.com/2016/04/28/mysql-char-varchar-set/)\n[MySQL 深入剖析 char varchar 类型，有了 VARCHAR，为什么还要有 CHAR？](https://www.jianshu.com/p/85ada7b1dbab)\n\n## MySQL 中的 JSON Data Type\n\n### 能够储存为的 JSON 值的格式\n\n- JSON 数组：被 `[]` 框住，由逗号分隔的值的列表；\n- JSON 对象：被`{}`框住，由逗号分隔的键值对的列表，键的类型必须为字符串。\n\n能够储存的类型包括字符串，数字，时间，布尔值。同时，两种类型的还可以嵌套，比如：\n\n```json\n[99, {\"id\": \"HK500\", \"cost\": 75.99}, [\"hot\", \"cold\"]]\n{\"k1\": \"value\", \"k2\": [10, 20]}\n```\n\n可以使用 JSON_OBJECT，JSON_ARRAY 来生成 JSON 格式的数据。\n\n## JSON 值的查询\n\n使用`JSON_EXTRACT`函数来查询 JSON，第一个参数为要查询的值，第二个参数中使用前导\\$字符代替要查询的值。JSON_EXTRACT 函数还有别名 ->。\n\n```sql\nSELECT JSON_EXTRACT('{\"id\": 14, \"name\": \"Aztalan\"}', '$.name');\n```\n\n## JSON 值的索引\n\n- JSON 数组：使用`[]`与序号下标的组合，`last`代表最后一个值的索引位置\n- JSON 对象：使用`.`操作符\n\n## JSON 值的修改\n\n- JSON_INSERT 函数只会把属性添加到对象中，前提是需要添加的属性在对象中还不存在。\n- JSON_REPLACE 函数只会更新对象中已经存在的属性。\n- JSON_SET 函数在属性存在时对属性进行更新，否则就将属性添加到对象中。\n\n## JSON 值的删除\n\nJSON_REMOVE 函数指定在输出某个 JSON 属性\n"},{"title":"Java 中的 Lambda 表达式","url":"/posts/40701/","content":"\n## Lambda 表达式的意义\n\nLambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。使其独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。不过，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。\n\n## Lambda 表达式特征\n\nLambda 表达式没有声明的方法，也即没有访问修饰符、返回值声明以及名字。\n\n## Lambda 表达式的结构\n\n- 一个 Lambda 表达式可以有零个或多个参数\n- 参数的类型既可以明确声明，也可以根据上下文来推断。例如：`(int a)`与`(a)`效果相同\n- 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：`(a, b)` 或 `(int a, int b)` 或 `(String a, int b, float c)`\n- 空圆括号代表参数集为空。例如：`() -> 42`\n- 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：`a -> return a*a`\n- Lambda 表达式的主体可包含零条或多条语句\n- 如果 Lambda 表达式的主体只有一条语句，花括号{}可省略，`return`关键字也可以省略，匿名函数的返回类型与该主体表达式一致\n- 如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空\n\n## Lambda 表达式举例\n\n```java\n// 1. 不需要参数,返回值为 5\n()  ->  5\n\n// 2. 接收一个参数(数字类型),返回其2倍的值\nx ->  2  * x\n\n// 3. 接受2个参数(数字),并返回他们的差值\n(x, y)  -> x – y\n\n// 4. 接收2个int型整数,返回他们的和\n(int x,  int y)  -> x + y\n\n// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)\n(String s)  ->  System.out.print(s)\n```\n\n## Lambada 表达式的作用域\n\n### 访问局部变量\n\n- 可以直接在 lambda 表达式中访问外层中的`final`局部变量\n- lambda 表达式中访问的外层局部变量时必须不可被后面的代码修改（即隐性的具有 final 的语义），Lambda 表达式中也不能修改\n- 在 Lambda 表达式当中被引用的变量的值不可以被更改。\n- 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。\n\n### 访问对象字段与静态变量\n\n- 和局部变量不同的是，Lambda 内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。\n- 不能访问接口的默认方法\n\n### Lambda 表达式中的 this\n\n- Lambda 表达式中使用 this 会引用创建该 Lambda 表达式的方法的 this 参数。\n"},{"title":"Java 中枚举和类的异同","url":"/posts/23197/","content":"\n## 不同点\n\n- 枚举类是一组相关数据的组合\n- 枚举类默认继承了 java.lang.Enum 类，而不是继承 Object 类，不能继承其他类\n- 非抽象枚举类默认使用`final`修饰，不能存在子类\n- 枚举类的构造器只能使用`private`修饰\n- 枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远不能产生实例，列出的实例，系统会自动添加 public static final 修饰\n- 枚举类默认带有`values()`方法，该方法可以很方便的遍历所有的枚举值\n- 常量值地址唯一,可以用==直接对比,性能会有提高\n\n## 相同点\n\n- 均可以实现接口\n"},{"title":"Java 中的序列化使用总结","url":"/posts/38899/","content":"\n## Serializable 序列化总结\n\n### Serializable 序列化特点\n\n`private static final long serialVersionUID = 1L`：用来保证能够相互序列化与反序列化\n\n静态变量不会被序列化，因为序列化保存的是**对象的状态**，而静态变量属于类的状态，因此**序列化并不保存静态变量**。\n\n### 父类的序列化\n\n一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。\n\n### Transient 关键字\n\nTransient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。\n\n### 自定义序列化\n\n在序列化过程中，虚拟机会试图调用对象类里的 writeObject() 和 readObject() 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。\n\n### 同一对象多次序列化\n\n第一次序列化写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。\n\n## Externalizable 序列化\n\n### Externalizable 序列化源码\n\n```java\npackage java.io;\n\nimport java.io.ObjectOutput;\nimport java.io.ObjectInput;\n\n\npublic interface Externalizable extends java.io.Serializable {\n    void writeExternal(ObjectOutput out) throws IOException;\n    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;\n}\n```\n\n### Externalizable 序列化特点\n\nExternalizable，使用该接口之后，之前基于 Serializable 接口的序列化机制就将失效。Externalizable 的序列化机制优先级要高于 Serializable 。\n\n实现 Externalizable 接口后，序列化的细节即\n`writeExternal()`和`readExternal()`需要由开发人员自己实现。\n\n实现 Externalizable 接口后，属性字段使用 transient 和不使用没有任何区别。\n\n使用 Externalizable 进行序列化时，必须要有默认的构造方法，通过反射先创建出该类的实例，然后再把解析后的属性值，通过反射赋值\n\n### Externalizable 举例\n\n```java\npackage Test;\n\nimport java.io.*;\n\nclass Person implements Serializable, Externalizable {\n    public static final long serialVersionUID = 1l;\n    private String name;\n    private int age;\n\n    public Person() {}\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeObject(this.name);\n        out.writeObject(this.age);\n    }\n\n    @Override\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        this.name = (String) in.readObject();\n        this.age = (Integer) in.readObject();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.setName(\"li\");\n        person.setAge(19);\n        try {\n            ObjectOutputStream objectOutputStream =\n                    new ObjectOutputStream(new FileOutputStream(new File(\"./li.txt\")));\n            objectOutputStream.writeObject(person);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            ObjectInputStream objectInputStream =\n                    new ObjectInputStream(new FileInputStream(new File(\"./li.txt\")));\n            Person person1 = (Person) objectInputStream.readObject();\n            System.out.println(person1.getAge());\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n## Serializable 和 Externalizable 序列化的不同\n\n- Serializable 是标识接口，实现该接口，无需重写任何方法；Externalizable 接口继承于 Serializable，实现该接口，需要重写 readExternal 和 writeExternal 方法\n- Serializable 提供了两种方式进行对象的序列化\n  - 采用默认序列化方式，将非 transatient 和非 static 的属性进行序列化\n  - 自定义编写 readObject() 和 writeObject() 完成部分属性的序列化\n- Externalizable 接口的实现方式一定要有**默认的无参构造函数**，而 Serializable 接口实现，其采用反射机制完成内容恢复，没有一定要有无参构造函数的限制\n- 采用 Externalizable 无需产生序列化 ID（serialVersionUID），而 Serializable 接口则需要\n\n## 参考\n\n[Java 序列化的高级认识](https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html)\n[Java 对象的序列化和反序列化源码阅读](https://www.cnblogs.com/woshimrf/p/java-serialize.html)\n[Java 序列化之 Externalizable](https://www.jianshu.com/p/411e18ceaa55)\n[JAVA 对象序列化（一）——Serializable](https://www.cnblogs.com/chenfei0801/archive/2013/04/05/3001149.html)\n[JAVA 对象序列化（二）——Externalizable](https://www.cnblogs.com/chenfei0801/archive/2013/04/06/3002146.html)\n[Serializable 和 Externalizable 浅析](https://my.oschina.net/wangmengjun/blog/1588096)\n"},{"title":"Java 泛型总结","url":"/posts/60082/","content":"\n## 泛型的作用\n\nJava 本身是强类型语言，每次操作都需要指定类型，但是有时候一系列操作（例如集合操作）可以使用于多种类型，为了节省代码，可以将类型参数化，这就是泛型。\n\n## 泛型的三种使用方式\n\n### 泛型类\n\n泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n\n例如：\n\n```java\npublic class Generic<T> {\n    private T key;\n\n    public Generic(T key) {\n        this.key = key;\n    }\n\n    public T getKey() {\n        return key;\n    }\n}\n\nGeneric generic = new Generic(\"li\");\n```\n\n其中`<T>`就代表泛型，意为`<T>`可以代表任意类型。注意的是泛型的类型只能是引用类型，而不能是基本类型。因为默认是`<? extends Object>`。\n\n### 泛型接口\n\n泛型接口与泛型类的定义与使用基本相似。\n\n泛型接口定义：\n\n```java\npublic interface Generator<T> {\n    public T next();\n}\n\n```\n\n当类实现了泛型接口却未传入泛型实参时：\n\n```java\n// 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\nclass FruitGenerator<T> implements Generator<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n```\n\n当类实现了泛型接口并传入泛型实参时：\n\n```java\n/**\n * 传入泛型实参时：\n * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>\n * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\n * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\n * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n */\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n### 泛型方法\n\n泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。\n\n举例：\n\n```java\n/**\n * 泛型方法的基本介绍\n * @param tClass 传入的泛型实参\n * @return T 返回值为T类型\n * 说明：\n *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。\n *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。\n *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。\n *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。\n */\npublic <T> T genericMethod(Class<T> tClass)throws InstantiationException ,\n  IllegalAccessException{\n        T instance = tClass.newInstance();\n        return instance;\n}\n```\n\n### 在泛型类里使用泛型方法\n\n泛型方法里声明了泛型<E>，即使泛型类中并未声明该泛型<E>，该泛型方法也可以使用泛型<E>，泛型方法也可声明泛型类中声明过的同名的泛型<T>，此时泛型<T>会是一个全新的类型。可以与泛型类中的泛型<T>不是同一类型。\n\n### 静态泛型方法\n\n静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上，即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。\n\n### 泛型方法的使用\n\n```java\n//静态方法\nStaticFans.StaticMethod(\"adfdsa\");//使用方法一\nStaticFans.<String>StaticMethod(\"adfdsa\");//使用方法二\n\n//常规方法\nStaticFans staticFans = new StaticFans();\nstaticFans.OtherMethod(new Integer(123));//使用方法一\nstaticFans.<Integer>OtherMethod(new Integer(123));//使用方法二\n```\n\n建议使用方法二，直接规定类型\n\n### 泛型约定标记符\n\nE - Element (在集合中使用，因为集合中存放的是元素)\nT - Type（Java 类）\nK - Key（键）\nV - Value（值）\nN - Number（数值类型）\n？ - 表示不确定的 java 类型\nS、U、V - 2nd、3rd、4th types\n\n## 参考资料\n\n[java 泛型详解](https://blog.csdn.net/s10461/article/details/53941091)\n[泛型：工作原理及其重要性](https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n[Java 泛型详解：和 Class 的使用](https://blog.csdn.net/qq_27093465/article/details/73229016)\n[Java 泛型详解](http://www.importnew.com/24029.html)\n"},{"title":"Java 中的 TreeMap","url":"/posts/59929/","content":"\nTreeMap 是一个通过红黑树实现的**有序**的**key-value**集合。该集合根据其**键的自然顺序**进行排序，或者根据**创建映射时提供的 Comparator **进行排序。\n\n## 构造函数\n\n```java\n// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。\nTreeMap()\n\n// 创建的TreeMap包含Map\nTreeMap(Map<? extends K, ? extends V> copyFrom)\n\n// 指定Tree的比较器\nTreeMap(Comparator<? super K> comparator)\n```\n\n## TreeMap 中的获取方法\n\n### TreeMap 的 Entry 相关函数\n\n返回一个 key-value 的映射对。\n\nfirstEntry()/lastEntry()：获得第一个/最后一个\nlowerEntry()/higherEntry()：获得刚好小于/大于的映射对，不存在则返回`null`\nfloorEntry()/ceilingEntry()：获得刚好小于等于/大于等于的映射对，不存在则返回`null`\npollFirstEntry()/pollLastEntry()：获得第一个/最后一个，并在元集合中删除这一个\n\n### TreeMap 的 key 相关函数\n\nfirstKey()、lastKey()、lowerKey()、higherKey()、floorKey()、ceilingKey()\n\n### TreeMap 的 values()函数\n\nvalues() 返回“TreeMap 中值的集合”\n\n### TreeMap 的 entrySet()函数\n\nentrySet() 返**TreeMap 的所有键值对组成的集合**，而且它单位是单个**键值对**\n\n## TreeMap 排序相关函数\n\n### 反向 TreeMap\n\n- descendingMap() 的作用是返回一个当前 TreeMap 排序顺序相反的 TreeMap。\n- descendingKeySet()的作用是返回一个当前 TreeMap 排序顺序相反的包含 key 的 Set 集合。\n\n## TreeMap 其他相关常用函数\n\n- 清空：clone()\n- 根据 key 获取值：get(Object key)\n- 判断是否为空：isEmpty()\n- 插入：put(K key, V value)\n- 根据键来删除：remove(Object key)\n- 获得集合大小：size()\n- 获得子集合： subMap(K fromInclusive, K toExclusive)\n\n## 遍历方式\n\n### 获取**键值对**、**键**、**值**的集合\n\n- entrySet()\n- keySet()\n- values()\n\n## 使用迭代器进行遍历\n\n使用遍历键来进行举例\n\n```java\n// 假设map是TreeMap对象\n// map中的key是String类型，value是Integer类型\nString key = null;\nInteger value = null;\nIterator iter = map.keySet().iterator();\nwhile (iter.hasNext()) {\n        // 获取key\n    key = (String)iter.next();\n        // 根据key，获取value\n    value = (Integer)map.get(key);\n}\n```\n\n## 使用 for-Each 进行遍历\n\n使用遍历键来进行举例\n\n```java\n// 假设map是TreeMap对象\n// map中的key是String类型，value是Integer类型\nSet<String> keys = map.keySet();\nfor(String key:keys){\n    System.out.println(key);\n}\n```\n"},{"title":"Java LinkedList 用法总结","url":"/posts/3868/","content":"\n## LinkedList 构造函数\n\n- 默认构造函数：`LinkedList()`\n- 带初始值的构造函数：`LinkedList(Collection<? extends E> collection)`\n\n## LinkedList 常用方法\n\n- add(int index, E element)：根据索引值添加值\n- addFirst()：在头部添加值\n- get(int index)：根据索引返回值\n- getFirst()：返回第一个值，如果为空则抛出异常\n- set(int location, E object)：在位置添加值\n- indexOf(Object object)：根据值返回索引，找不到则返回`-1`\n- clear()：清空 LinkedList\n- peek()：返回第一个值，如果为空则返回`null`\n- poll()：删除并返回第一个节点\n- offer(E e)：将 e 添加双向链表末尾\n- pop()：删除并返回第一个节点\n- push(E e)：将 e 插入到双向链表开头\n- remove(int location)：根据索引删除值\n- remove(Object object)：根据内容删除\n- size()：返回列表的长度\n- toArray()：返回内容数组\n- clone()：将全部元素克隆到一个新的 LinkedList 对象中并返回\n\n### LinkedList 修改方法总结\n\n|      | 头部抛出异常  | 头部特殊值    | 尾部抛出异常 | 尾部特殊值   |\n| ---- | :------------ | :------------ | :----------- | :----------- |\n| 插入 | addFirst(e)   | offerFirst(e) | addLast(e)   | offerLast(e) |\n| 移除 | removeFirst() | pollFirst()   | removeLast() | pollLast()   |\n| 检查 | getFirst()    | peekFirst()   | getLast()    | peekLast()   |\n\n### LinkedList FIFO(先进先出)的队列方法总结\n\n| 队列方法  | 等效方法      |\n| --------- | :------------ |\n| add(e)    | addLast(e)    |\n| offer(e)  | offerLast(e)  |\n| remove()  | removeFirst() |\n| poll()    | pollFirst()   |\n| element() | getFirst()    |\n| peek()    | peekFirst()   |\n\n### LinkedList LIFO(后进先出)的栈方法总结\n\n| 栈方法  | 等效方法      |\n| ------- | :------------ |\n| push(e) | addFirst(e)   |\n| pop()   | removeFirst() |\n| peek()  | peekFirst()   |\n\n## LinkedList 遍历方法\n\n### 通过快速随机访问遍历 LinkedList\n\n```java\nint size = list.size();\nfor (int i=0; i<size; i++) {\n    list.get(i);\n}\n```\n\n### 通过另外一种 for 循环来遍历 LinkedList\n\n```java\nfor (T element:list){\n    System.out.println(T);\n}\n```\n\n### 通过迭代器遍历, 即通过 Iterator 去遍历\n\n```java\nfor(Iterator iter = list.iterator(); iter.hasNext();){\n    iter.next();\n}\n```\n\n### forEach()方法\n\n```java\nlist.forEach(item -> System.out.println(item));\n```\n"},{"title":"Java 中的 Object 类、String 类和数组的常用方法","url":"/posts/16025/","content":"\n## Object 类常用方法\n\n- equals()：返回是否相等，默认比较内存地址是否相等，一般需要根据情况重写，重写时需要满足以下原则：\n\n  - 自反性（reflexive）。对于任意不为 null 的引用值 x，x.equals(x) 一定是 true。\n  - 对称性（symmetric）。对于任意不为 null 的引用值 x 和 y ，当且仅当 x.equals(y)是 true 时，y.equals(x)也是 true。\n  - 传递性（transitive）。对于任意不为 null 的引用值 x、y 和 z，如果 x.equals(y) 是 true，同时 y.equals(z) 是 true，那么 x.equals(z)一定是 true。\n  - 一致性（consistent）。对于任意不为 null 的引用值 x 和 y，如果用于 equals 比较的对象信息没有被修改的话，多次调用时 x.equals(y) 要么一致地返回 true 要么一致地返回 false。\n\n- hashCode()：返回对象的的 hash 值\n\n  - 调用 equals 返回 true 的两个对象必须具有相等的哈希码。\n  - 如果两个对象的 hashCode 返回值相同，调用它们 equals 方法不一返回 true 。\n\n- toString()：默认返回的字符串很像是 对象名+@+对象内存地址，需要根据特殊的情况进行重写\n- getClass()：返回实例运行时真正所指的对象所属的类的类型类\n- clone()：默认调用 clone 方法的是一个对象的引用，而不是深拷贝，需要根据不同的情况进行改写\n\n## String 类常用方法\n\n### 静态方法\n\n- String valueOf(): 将对象或者其他基本类型转换为字符串类型\n\n### 实例方法\n\n- charAt(int index): 根据对应的索引返回对应的字符\n- compareTo(String anotherString): 将此字符串与字符串参数进行比较，若完全一致则返回 0，字典序大则返回正数，小则返回负数\n- concat(String anotherString): 将两个字符串连接成一个字符串\n- contains(CharSequence s): 检查是否包含相应的字符\n- endsWith(String suffix)：是否以某字符结尾\n- equals(Object anObject)：是否相等\n- indexOf(String str)：返回字符或者字符串的位置，未找到则返回`-1`\n- length()：获取字符串的长度\n- replace(char oldChar, char newChar)：修改替代字符串\n- split(String regex)：分隔字符串\n- toLowerCase()：转换为小写\n- subString(): 截取字符串\n\n## 数组\n\n### 数组的定义\n\n数组变量的声明和创建：\n\n- `dataType[] arrayName = new dataType[arraySize];`\n- `dataType[] arrayName = {value0, value1, valuek};`\n\n例如：`double[] myList = new double[size];`\n\n#### 二维数组的定义\n\n- `dataType[][] arrayName = new type[size1][size2];`\n- `dataType[][] arrayName = { {value1}, {value2}, {value3} };`\n\n例如： `int[][] myList = { {1,1,1,1,1}, {2,2,2,2,2}, {3,3,3,3,3} };`\n注意：定义二维数组必须指定其行数，列数可以指定，可以不指定。\n\n### 数组的遍历\n\n- 利用索引进行循环\n\n```java\npublic class TestArray {\n   public static void main(String[] args) {\n      double[] myList = {1.9, 2.9, 3.4, 3.5};\n\n      // 打印所有数组元素\n      for (int i = 0; i < myList.length; i++) {\n         System.out.println(myList[i] + \"\");\n      }\n```\n\n- For-Each 循环\n\n```java\npublic class TestArray {\n   public static void main(String[] args) {\n      double[] myList = {1.9, 2.9, 3.4, 3.5};\n\n      // 打印所有数组元素\n      for (double element: myList) {\n         System.out.println(element);\n      }\n   }\n}\n```\n\n### Arrays 类的静态方法\n\n- 给数组赋值：通过 fill 方法。\n- 对数组排序：通过 sort 方法,按升序。\n- 比较数组：通过 equals 方法比较数组中元素值是否相等。\n- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作，返回索引值。\n\n## 参考资料\n\n- [Java 数组](http://www.runoob.com/java/java-array.html)\n- [java Clone 使用方法详解](http://www.cnblogs.com/felixzh/p/6021886.html)\n"},{"title":"Java 中的类型转换和自动拆装箱","url":"/posts/46251/","content":"\n## 基本类型的自动类型转换和强制类型转换\n\n### 自动类型转换\n\n#### 赋值和方法调用中的类型转换\n\n转换原则：\n\n- 从低位类型到高位类型自动转换。类型排序：byte < short < int < long < float < double\n- boolean 类型不与其它类型的值发生转换。\n\n#### 运算中的类型转换\n\n- 基本就是先转换为高位数据类型，再参加运算\n- byte short char 运算会转换为 int\n- 使用赋值运算符时，系统会自动强制将运算结果转换为目标变量的类型\n- 运算符为自动递增运算符（++）或自动递减运算符（--）时，如果操作数为 byte，short 或 char 类型不发生改变；\n\n### 强制类型转换\n\n使用`(int) 变量`的类型将变量强制转换类型，高位向低位强制转换时会有精度损失。\n\n## 引用类型的类型转换\n\n假设有一个 Animal 的类，有一个 Dog 类继承于 Animal 类，语句\n\n```java\nAnimal animal = new Dog();\n```\n\n变量 animal 已经被自动**向上造型**成了 Animal 类型的变量，但是实际上 animal 在内存中的本质还是 Dog 类型，可以通过语句\n\n```java\nDog dog = (Dog)animal;\n```\n\n强制转换成 Dog 类型，这就是**向下造型**。\n\n**向下造型**也会有失败的时候，例如：\n\n```java\nAnimal animal = new Animal();\nDog dog = (Dog)animal;\n```\n\n这个系统会抛出 ClassCastException 异常信息，这是因为 animal 的真实身份是 Animal 类型，也就是 Dog 的父类，而不是 Dog 类型，这时的强制转换就会出现错误。\n\n## Java 中的自动拆装箱\n\nJava 中原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double 以及 Boolean。\n\n- 自动装箱：将原始类型转换成对应的封装类型\n- 自动拆箱：将封装类型转换成对应的原始类型\n\n自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。\n\n注意事项：\n\n- 方法重载时，不会发生自动拆装箱\n- 使用`==`对两个对象进行比较时，不会发生自动拆装箱\n- 将一个没有初始化的对象拆箱时，会出现`NullPointerException`异常\n"},{"title":"Java 访问控制修饰符","url":"/posts/45281/","content":"\nJava 访问控制修饰符有`default`、`public`、`private`、`protected`四种。\n\n## `default`\n\n有些地方称`friendly`，是缺省默认的修饰符，可以修饰类、接口、变量及方法，在同一包内均被可见。\n\n## `public`\n\n对所有类均可见，可以用来修饰类、接口、变量及方法。\n\n## `private`\n\n- 用来修饰变量和方法：只在同一类内可见，一般建议成员变量均被控制为`private`，而通过`public`的 get 和 set 方法来修改和访问。`private`修饰方法时，子类也不能使用此方法。\n- 类和接口一般不能用`private`修饰(内部类除外)。\n\n例如：\n\n```java\npublic class Animal {\n    private int age;\n    private int weight;\n    private String name;\n\n    public Animal(String name) {\n        this.name = name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public int getWeight() {\n        return this.weight;\n    }\n```\n\n## `protected`\n\n- 用来修饰变量和方法：\n\n1. 不同包，非子类不可见\n2. 同一包内其他类及子类可见\n3. 子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的 `protected` 方法，而不能访问父类实例的 `protected` 方法\n\n```java\npackage p2;\nclass MyObject2 {\n    protected Object clone() throws CloneNotSupportedException{\n       return super.clone();\n    }\n}\n\npackage p22;\npublic class Test2 extends MyObject2 {\n    public static void main(String args[]) {\n       MyObject2 obj = new MyObject2();\n       obj.clone(); // Compile Error         ----（1）\n\n       Test2 obj2 = new Test2();\n       obj2.clone(); // Compile OK         ----（2）\n    }\n}\n```\n\n- 一般不能用`protected`来修饰类和接口(内部类除外)。\n\n## 参考资料\n\n- [JAVA 修饰符类型(public,protected,private,friendly)](https://blog.csdn.net/johnstrive/article/details/5880357)\n- [Java protected 关键字详解](http://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html)\n"},{"title":"Java 中的类、抽象类和借口之间的异同","url":"/posts/43519/","content":"\n## 接口的一些特性\n\n- 接口中不能有构造方法\n- 接口中的所有方法都会被自动声明为`public`，且只能为`public`\n- 接口中定义的`变量`会自动转换为`public final static`，即为**常量**，必须被显式的初始化\n- 接口中的所有方法都是抽象方法，不能包含实现的方法，也不能包含静态方法\n- 实现接口的非抽象类必须实现接口的**所有**方法，而抽象类则不需要\n- 一个类可以实现多个接口\n\n## 抽象类的一些特性\n\n- 抽象类不能被实例化，但可以有构造函数\n- 抽象方法必须由子类进行重写\n- 只要包含一个抽象方法的类，就必须定义为抽象类，不管是否还包含其他方法\n- 抽象类中可以包含具体的方法，也可以不包含抽象方法\n- 抽象类可以包含普通成员变量，其访问类型可以任意\n- 抽象类也可以包含静态成员变量，其访问类型可以任意\n- 子类中的抽象方法不能与父类的抽象方法同名\n- abstract 不能与 private、static、final 或 native 并列修饰同一个方法\n- 一个类只能继承一个抽象类\n\n## 接口与抽象类的区别\n\n- 抽象类：被继承体现的是：”is a”的关系。抽象类是对类的抽象，抽象类所体现的是一种继承关系，即父类和派生类在概念本质上应该是相同的。\n- 接口：被实现体现的是：”like a”的关系。接口是对动作的抽象，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n## 参考资料\n\n- [java 提高篇（四）-----抽象类与接口](https://blog.csdn.net/chenssy/article/details/12858267)\n- [抽象类和接口的区别](https://juejin.im/entry/59b0a3556fb9a0248a4023d0)\n- [Java 基础篇(一)：接口与抽象类](https://www.jianshu.com/p/2b5a9bdcd25f)\n- [Java 抽象类与接口的区别](http://www.importnew.com/12399.html)\n- [Java 基础 接口和抽象类](https://www.jianshu.com/p/eb77a2e64fda)\n"},{"title":"Java 中的异常与错误","url":"/posts/57291/","content":"\n## 异常（Exception）与错误（Error）的区别与联系\n\n- Error 类与 Exception 类都是继承于 Throwable 类。\n- Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等等。对于这类错误，Java 编译器不去检查他们，对于这类错误导致的程序中断，仅靠程序本身无法恢复和预防。\n- Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能去处理异常，使程序恢复运行，而不应该随意终止异常。\n\n## 运行时异常（RuntimeException）与受检查型异常（Checked Exception）\n\n- 运行时异常：其特点是 Java 编译器不去检查它，当程序中可能出现这类异常时，即使没有用 try……catch 捕获，也没有用 throws 抛出，还是会编译通过，但运行时会就终止，如除数为零的 ArithmeticException、错误的类型转换、数组越界访问和试图访问空指针等。处理 RuntimeException 的原则是：如果出现 RuntimeException，那么一定是程序的逻辑出了问题，应该及时修改程序。\n\n- 受检查型异常：这类异常如果没有 try……catch 也没有 throws 抛出，编译是通不过的。这类异常一般是外部错误，例如文件找不到、试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。\n\n## 异常处理方式\n\n- 使用 try..catch..finally 语句进行捕获处理\n- 在产生异常的方法声明后面写上 throws 某一个 Exception 类型\n\n### try-catch-finally-return 执行顺序\n\n- 不管是否有异常产生，finally 块中代码都会执行\n- 当 try 和 catch 中有 return 语句时，finally 块仍然会执行\n- finally 是在 return 后面的表达式运算后执行的，所以函数返回值是在 finally 执行前确定的。无论 finally 中的代码怎么样，返回的值都不会改变，仍然是之前 return 语句中保存的值\n- finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值\n\n## 常见异常种类\n\n### 运行时异常\n\n- `java.lang.ArithmeticException`：算术条件异常。譬如：整数除零\n- `java.lang.ArrayStoreException`：将错误的类型储存到对象数组里，例如：\n\n```java\nObject x[] = new String[3];\nx[0] = new Integer(0);\n```\n\n- `java.lang.ClassCastException`：强制类型转换异常，例如：\n\n```java\nObject x = new Integer(0);\nSystem.out.println((String)x);\n```\n\n- `java.lang.IndexOutOfBoundsException`：索引越界\n- `java.lang.NullPointerException`：空指针异常，常见对象没有实例化便引用\n\n### 受检查型异常\n\n- `java.lang.ClassNotFoundException`：无法找到对应的类\n- `java.lang.NoSuchMetodException`：无法找到对应的方法\n- `java.io.IOException`：输入输出异常\n\n## 参考资料\n\n[谈一谈 Java 中的 Error 和 Exception](https://blog.csdn.net/goodlixueyong/article/details/47122487)\n"},{"title":"初识单一职责原则","url":"/posts/46716/","content":"\n## 单一职责基本概念\n\n- 单一：单一意味着某些工作是独立的。比如，在类中，类方法仅完成某一件独立的事情。\n- 职责：职责指软件系统中，每一个指派给特定方法、类、包和模块所完成的工作或者动作。\n\n方法层面：类方法的单一职责是最单纯的，很具体的，不掺杂任何额外信息，只关心输入、输出、和职责。\n类层面：一个类只围绕与一个功能，并且**引起其变化的原因只有一个**。让一个类只负责一件事,将关联性强的内容聚合到一个类中。\n\n## 单一职责优点\n\n- 降低了类的复杂度。\n- 提高了代码的可读性。\n- 提高了系统的可维护性。\n- 变更引起的风险变低了。\n\n## 灵活之处\n\n对类职责的细分，“职责”和“变化原因”都是都要根据不同的项目、不同的环境来具体讨论。\n\n## 参考\n\n[单一职责原则](http://kklin.farbox.com/post/she-ji-mo-shi/1-she-ji-yuan-ze/1-dan-zhi-ze-yuan-ze)\n[设计模式之禅 - 单一职责原则](https://www.kancloud.cn/sstd521/design/193491)\n"},{"title":"IntelliJ IDEA 初探","url":"/posts/37516/","content":"\n## 使用 IntelliJ IDEA 创建 HelloWorld 项目\n\n1. 新建一个项目，选择好 SDK\n\n![](1-b87580ab75f14564bf63e0249b53b15a.png)\n\n2. 选择项目模版，本项目不用选择\n\n![](2-b5b0afc0cc0c988f1f63da8be4492852.png)\n\n3. 选择项目名称以及项目路径\n\n![](3-767c385ddb64c1ada5ef3df51e5d0548.png)\n\n4. 在 src 文件夹下面新建名为`HelloWorld`的类\n\n![](4-680075c5bce69b14faed485def96d298.png)\n\n5. 写入代码\n\n![](5-d86b0d16af471d02d4930a2958f5e932.png)\n\n6. 使用快捷键`Shift+Alt+F10`即可运行代码，即可以在控制台中看到输出\n\n![](6-5b10f20121a98ca0f30d8e6282eed979.png)\n\n7. 使用快捷键`Ctrl+F8`即可在当前行添加断点\n\n![](7-beb8c559c677481dcb15dcaf918080e3.png)\n\n## 推荐插件\n\n- Key Promoter：会提示当前操作的快捷键\n- Save Action：可以设置保存前的操作，如格式化代码\n\n## 常用快捷键\n\n- `Ctrl+Alt+s`：打开设置\n- `Shift+F10`：运行项目\n- `Shift+F9`：编译项目\n\n更多快捷键可参考：[IntelliJ IDEA 常用快捷键整理](https://segmentfault.com/a/1190000011544042)\n"},{"title":"JVM、JRE 与 JDK","url":"/posts/36121/","content":"\n## JVM(Java Virtual Machine)Java 虚拟机\n\nJVM 是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为.class 的目标字节码，这种目标字节码文件在虚拟机上执行时，把字节码解释成具体平台上的机器指令执行，因此 Java 可以稳定安全的实现跨平台。\n\n## JRE(Java Runtime Environment) Java 运行环境\n\nJRE 包含了 JVM 与 java 基础类库，是使用 java 语言编写的程序运行所需要的软件环境，提供给想运行 java 程序的用户使用的。\n\n## JDK(Java Development Kit) Java 开发工具包\n\n是提供给开发人员开发 java 程序所需的开发工具包。JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac 和打包器等工具，还包含了很多 java 程序调试和分析的工具：jconsole，jvisualvm 等工具软件，以及编写 java 程序所需的文档和 demo 例子程序。\n\n![](java-e2a96dff5e7e29b59c5ed7b218e0dac5.jpg)\n\n我们开发的实际流程是：我们利用 JDK（调用 JAVA API）开发了属于我们自己的 JAVA 程序后，通过 JDK 中的编译程序（javac）将我们的文本 .java 文件编译成 JAVA 字节码，在 JRE 上运行这些 JAVA 字节码，JVM 解析这些字节码，映射到 CPU 指令集或 OS 的系统调用。\n"},{"title":"原生 JavaScript 常用的本地浏览器存储方法总结","url":"/posts/31128/","content":"## localStorge\n\n`Storage` 提供了访问特定域名下的会话存储（session storage）或本地存储（local storage）的功能，例如，可以添加、修改或删除存储的数据项。容量为 5MB。\n\n### 属性\n\nStorage.length: 返回一个 Storage 对象中的数据项数量，整数。\n\n### 方法\n\n- Storage.getItem(): 传入键名作为参数，返回键名对应的值。\n- Storage.setItem(): 传入键名与值，将键值对添加到存储中，如果键名存在，则会更新其对应的值。\n- Storage.removeItem(): 传入键名，并将该键值对从存储中删除。\n- Storage.clear(): 清空存储。\n- Storage.key(): 传入数值 n，返回存储中的第 n 个键名。\n\n### 注意事项\n\n1. 除了前面提到的方法，还可以用对象的`[]`和`.`方法来读取或赋值。\n2. localStorage 会自动将本事转换为字符串形式，可以使用JSON.stringify()这个方法，来将JSON转换成为JSON字符串，使用JSON.parse()方法，将JSON字符串转换成为JSON对象\n\n\n## sessionStorage\n\n属性与方法都与 localStorage 类似，但 sessionStorage 只用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。\n\nlocalStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。\n\n## Cookie\n\n[Document.cookie](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie)\n\nCookie 的大小被限制在 4kb，只要有请求涉及 cookie, cookie 就要在服务器和浏览器之间来回传送。\n\ndocument_.cookie = _newCookie; newCookie是一个键值对形式的字符串。需要注意的是，用这个方法一次只能对一个cookie进行设置或更新。\n\n### document.cookie 属性\n\n- expires 属性：来对 cookie 的有效期进行设置，现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。\n- path 属性：它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。\n- domain 属性：domain属性可以使多个web服务器共享cookie。\n- secure 属性：布尔值，指定在网络上如何传输 cookie,默认为 false。\n\n### 写入 Cookie\n\n```\ndocCookies.setItem(name, value[, end[, path[, domain[, secure]]]])\n```\n\n- name: 名字，名字相同的会进行覆盖，字符串\n- value：值，字符串\n- end: 最大年龄的秒数\n\n## 得到 Cookie\n```\ndocCookies.getItem(name)\n```\n读取一个cookie。如果cookie不存在返回`null`\n\n## 移除 Cookie\n\n```\ndocCookies.removeItem(name[, path],domain)\n```\n\n## 检测 Cookie\n```\ndocCookies.hasItem(name)\n```\n\n## 得到所有 Cookie 的列表\n\n```\ndocCookies.keys()\n```\n"},{"title":"JSON 总结","url":"/posts/58769/","content":"\n## 什么是 JSON？\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON是一种嵌套层级结构，可以通过JavaScript进行解析。\n\n在 JSON 中：\n\n*   数据是以键值对的形式存储的\n*   不同数据项之间以逗号分隔，最后一个数据项后面不需要逗号\n*   通过大括号来保存JSON对象\n*   在JSON对象内容，数据的值也可以是数组，通过中括号来保存数组\n\n## JSON 的值\n\nJSON 的值可以是以下数据结构：\n\n*   数值（整数或浮点数）\n*   字符串（在双引号中）：是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。\n*   逻辑值（true 或 false）\n*   数组（在中括号中）：一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。\n*   对象（在大括号中）：数组是值（value）的有序集合。对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。\n*   null\n\n## JSON 对象方法\n\n### JSON.stringify()\n\nJSON.stringify() 方法用于将一个字符串转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse() 方法还原。\n\n### JSON.parse()\n\nJSON.parse() 方法用于将 JSON 字符串转换成对应的值。\n\n## JSON 和 JavaScript 的关系\n\nJSON 是依据 JavaScript 文字对象表示法的子集所创建的数据交换格式。\n\nJavaScript的对象是面向对象语言的一种表示方式，Json则是数据传输的一种格式（比如XML），所以二者之间在定义上没有很大关系；但是二者的格式书写非常相似（有一个细节就是：JS对象的key是可以使用引号也可以不使用；可是Json格式则必须对key使用引号），所以JS对象与Json非常容易转换。\n\n### JSON 和 JavaScript 类型的区别\n\n| JavaScript类型 | JSON 的不同点 |\n| --- | --- |\n| 对象和数组 | 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。 |\n| 数值 | 禁止出现前导零，JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出SyntaxError；如果有小数点, 则后面至少跟着一位数字。 |\n| 字符串 | 字符串必须用**双引号**括起来, 只支持某些空白字符：制表符，回车，换行，空格|\n\n\n## JSON 的适用场景\n\n- API 外部访问接口，一般数据交互格式通常为 JSON\n- Ajax 中实现异步加载\n"},{"title":"JavaScript 对象基础总结","url":"/posts/63313/","content":"\n## 对象的组成\n\n一个对象由许多的成员组成，每一个成员都拥有一个名字和一个值。每一个名字/值（name/value）对被逗号分隔开，并且名字和值之间由冒号（:）分隔。\n\n对象成员的值可以是任意的，在我们的person对象里有字符串(string)，数字(number)，两个数组(array)，两个函数(function)。前4个成员是资料项目，被称为对象的属性(property)，后两个成员是函数，允许对象对资料做一些操作，被称为对象的方法(method)。\n\n```js\nvar person = {\n  name : ['Bob', 'Smith'],\n  age : 32,\n  gender : 'male',\n  interests : ['music', 'skiing'],\n  bio : function() {\n    alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.');\n  },\n  greeting: function() {\n    alert('Hi! I\\'m ' + this.name[0] + '.');\n  }\n};\n```\n\n## 对象的表示方法\n\n### 点表示法\n\n可以使用点表示法(dot notation)来访问对象的属性和方法。对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点(.)，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。\n\n```js\nperson.age\nperson.interests[1]\nperson.bio()\n```\n\n### 中括号表示法\n\n```js\nperson['age']\nperson['name']['first']\n```\n\n使用中括号表示法的优势在于，点表示法只能接受字面量的成员的名字，不接受变量作为名字，同时中括号表示法可以表示属性名中带有空格的属性。\n\n同时使用中括号时属性名也可以通过计算获得。\n\n### 设置对象成员\n\n```js\nperson.age = 45\nperson['name']['last'] = 'Cratchit'\n```\n\n直接负值，对于已经存在的属性，则会更新值，不存在的属性则会增加属性。\n\n删除属性：\n\n```js\ndelete person.age\n```\n\n## 判断有无\n\n使用`in`可以判断一个对象是否有某个属性\n\n\n## 遍历\n\n### for…in…\n\n可以使用`for in`在属性内部进行遍历：\n\n```\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor(let key in user) {\n  // keys\n  console.log( key );  // name, age, isAdmin\n  // values for the keys\n  console.log( user[key] ); // John, 30, true\n}\n```\n\n### Object.keys(obj)\n\n使用 Object.keys(obj) 返回一个包含 key 的数组。\n\n```js\nvar obj = {\n  \"name\": \"Poly\",\n  \"career\": \"it\"\n}\n\nconsole.log(Object.keys(obj));  //[ 'name', 'career' ]\n\nfor (let i of Object.keys(obj)) {\n  console.log(obj[i]);\n}    //Poly  it\n```\n\n\n### Object.getOwnPropertyNames(obj)\n\n用于返回对象的自有属性，包括可枚举和不可枚举的。\n\n```js\nvar obj = {\n  \"name\": \"Poly\",\n  \"career\": \"it\"\n}\n\nconsole.log(Object.getOwnPropertyNames(obj));   //[ 'name', 'career' ]\n```\n","tags":["JavaScript"]},{"title":"JavaScript 学习笔记","url":"/posts/20244/","content":"\n## 坑多水深\n\n### 不可变的原始值与可变的对象引用\n\n[理解 JavaScript：不可变的原始值与可变的对象引用](http://laichuanfeng.com/study/javascript-immutable-primitive-values-and-mutable-object-references/)\n[让人犯晕的 JavaScript 变量赋值](http://hellobug.github.io/blog/javascript-variable-assignment/)\n\n### [基本字符串和字符串对象的区别](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String#基本字符串和字符串对象的区别)\n\n字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。JavaScript 会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。\n\n### 浅拷贝\n\n例如 Array 的 concat 方法：\nconcat 方法不会改变 this 或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示：\n\n- 对象引用（而不是实际对象）：concat 将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。\n- 数据类型如字符串，数字和布尔（不是 String，Number 和 Boolean 对象）：concat 将字符串和数字的值复制到新数组中。\n\n## 块级作用域\n\n### 什么是块级作用域\n\n块级作用域即`{}`内的作用域，但是在 for 判断语句中，for 后面的内容也属于块级作用域，块级作用域的声明有 let 和 const 两种。外层作用域无法读取内层作用域的变量。\n\nES6 中，明确运行在块级作用域中声明函数（例如在 try…catch…中），同时还规定，在块级作用域中，函数声明的行为类似 let, 在块级作用域之外不可引用。ES6 中，函数声明会提升到函数作用域的头部。\n\n### var 声明和 let 声明，const 声明的区别\n\nvar 作用于函数作用域，可以重复声明，在作用域运行的初期就会被声明变量，但是不会被赋值，这被称为变量提升，此时内层变量有可能会覆盖外层变量。\n\nlet const 作用于块级作用域，在同一作用域内不能重复声明，即内层变量可以声明同名外层变量，声明的变量不会覆盖上级同名的变量。无变量提升，存在临时死区。\n\nconst 声明的同时需要赋值，且不能重复赋值，如果声明的是对象的话，可以修改对象或者数组的内容，若需定义的对象或者数组的内容也不变化，可以使用 object.freeze(arr)进行冻结。冻结指的是不能向这个对象或数组添加新的属性，不能修改已有属性的值，不能删除已有属性。\n\n同时注意**不能在函数内部重新声明参数**：\n\n```html\nfunction func(arg) { // 报错 let arg; } function func(arg) { // 不报错 { let\narg; } }\n```\n\n### 临时性死区\n\n若块作用域中存在 let 和 const 指令，则它们声明的变量，从一开始就形成了封闭作用域，它所声明的变量就绑定到这个区域，不再受外部的影响。使用 let 命令声明变量之前，该变量都是不可用的（不可获取，不可使用等），这称为“临时性死区”。凡是在声明之前就使用这些变量，就会报错。例如：\n\n```\nvar i= 6;\nif (i > 5) {\n    i = 3; // 报错\n    let i;\n}\n```\n\n## 字符串\n\n### indexOf()\n\nstr.indexOf(searchValue[, fromIndex])：返回调用 String 对象中第一次出现的指定值的索引，开始在 fromIndex 进行搜索，区分大小写。如果未找到该值，则返回-1。\n\n奇怪的技巧：使用 indexOf()来统计字符串中字母出现的次数。在下例中，设置了 count 来记录字母 e 在字符串 str 中出现的次数：\n\n```javascript\nvar str = \"To be, or not to be, that is the question.\";\nvar count = 0;\nvar pos = str.indexOf(\"e\");\n\nwhile (pos !== -1) {\n  count++;\n  pos = str.indexOf(\"e\", pos + 1);\n}\n\nconsole.log(count); // displays 4\n```\n\n### lastIndexOf()\n\nstr.lastIndexOf(searchValue[, fromIndex]): 返回指定值在调用该方法的字符串中**最后出现的位置**，如果没找到则返回 -1。从该字符串的**后面向前查找**，从 fromIndex 处开始。\n\n```\n\"canal\".lastIndexOf(\"a\")   // returns 3\n\"canal\".lastIndexOf(\"a\",2) // returns 1\n\"canal\".lastIndexOf(\"a\",0) // returns -1\n```\n\n### slice()\n\nstr.slice(beginSlice[, endSlice])：方法提取一个字符串的一部分，不修改原字符串，并返回一新的字符串。\n\nslice() 提取的新字符串包括 beginSlice 但**不包括 endSlice**。\n\n若参数中有负值时，会被当做 sourceLength + beginSlice/endSlice 看待，即最后一个字符的索引为`-1`。endSlice 值为空时，默认索引到字符串末尾。\n\n### split()\n\nstr.split([separator[, limit]]): 方法使用指定的分隔符字符串将一个 String 对象分割成**字符串数组**，以将字符串分隔为子字符串，以确定每个拆分的位置。separator 将会被删除，limit 表示返回的数量限制。若 separator=\"\", 则返回每一个字符。\n\n### toLowerCase() & toUpperCase()\n\n转换大小写，皆返回新的字符串。\n\n### replace()\n\nstr.replace(substr, newSubStr)，注意是返回新的字符串，原字符串不会变化\n\n### substr()\n\nstr.substr(start[, length])：在字符串中抽取从 start 下标开始的指定数目的字符。其返回值为一个字符串，包含从 str 的 start（包括 start 所指的字符）处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。另外如果 start 为负数，则表示从字符串尾部开始算起。\n\n### includes()\n\nstr.includes(searchString[, position]): 要在此字符串中搜索的字符串。position 可选, 从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 0。如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。\n\n### startsWith()\n\nstr.startsWith(searchString [, position]): 判断字符串的起始位置是否匹配其他字符串中的字符。\nstr.endsWith(searchString [, position]):\n\n### trim()\n\ntrim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。\n\n### valueOf()\n\nvalueOf() 方法返回一个 String 对象的原始值（primitive value）。\n\n使用 String() 方法将其它对象转化为字符串可以被认为是一种更加安全的做法，虽然该方法底层使用的也是 toString() 方法，但是针对 null/undefined/symbols，String() 方法会有特殊的处理\n\n### charAt() charCodeAt() str[]\n\nstr.charAt(index) 返回 index 位置的字符，str[index] 也可以返回 index 位置的字符。 str.charCodeAt(index) 返回 index 位置字符的 Unicode 编码。\n\nindex 均不可以为赋值。\n\n## 数组\n\n[js 数组方法全面总结](https://www.jianshu.com/p/a339893df4aa)\n\n### toString()\n\narr.toString(): 对于数组对象，toString 方法连接数组并返回一个字符串，其中包含**用逗号分隔**的每个数组元素。当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。\n\n### join()\n\narr.join(\"separator\"): 如果省略()，数组元素用逗号分隔。默认为 \",\"。如果 separator 是空字符串(\"\")，则所有元素之间都没有任何字符。如果 arr.length 为 0，则返回空字符串。如果元素是 undefined 或者 null， 则会转化成空字符串。\n\njoin()方法不会改变原数组。\n\n### push() pop() shift() unshift()\n\n皆为修改原数组，删除元素时，会返回元素。\n\n### slice()\n\narr.slice([begin], [end])，**不修改元数组**，返回一个浅复制原数组中额元素的一个新数组。原数组的元素会按照下述规则拷贝：\n\n- 如果该元素是个对象引用 （不是实际的对象），例如 Object()对象，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n- 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。\n\n### splice()\n\narray.splice(start[, deleteCount[, item1[, item2[, ...]]]]): 从 start 位置开始，删除 deleteCount 个数量的元素，然后将后面的 item\\* 填入 start 位置。返回被删除的元素。\n\n注意这个方法**会对原数组进行修改**。\n\n### 数组的访问\n\n虽然数组的元素可以看作是数组对象的属性，但是却不能用 `.` 操作符来访问元素。并不是 JavaScript 数组有什么特殊之处，而是因为在 JavaScript 中，以数字开头的属性不能用点号引用，必须用方括号。比如，如果一个对象有一个名为 3d 的属性，那么只能用方括号来引用它。下面是具体的例子：\n\n```\nvar years = [1950, 1960, 1970, 1980, 1990, 2000, 2010];\nconsole.log(years.0);   // 语法错误\nconsole.log(years[0]);  // √\n\nrenderer.3d.setTexture(model, 'character.png');     // 语法错误\nrenderer['3d'].setTexture(model, 'character.png');  // √\n```\n\n### Array 的构建\n\n#### new Array()\n\n构建新的数组对象\n\n#### Array.of() & Array()\n\nArray.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\n\nArray.of() 和 Array() 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为 7 的空数组（注意：这是指一个有 7 个空位的数组，而不是由 7 个 undefined 组成的数组）。\n\n```\nArray.of(7);       // [7]\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]\n```\n\n#### Array.from()\n\nArray.from(arrayLike[, mapFn[, thisArg]])：arrayLike\n想要转换成数组的伪数组对象或可迭代对象。mapFn (可选参数)\n如果指定了该参数，新数组中的每个元素会执行该回调函数。thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。\n\nArray.from() 可以通过以下方式来创建数组对象：\n\n- 伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）\n- 可迭代对象（可以获取对象中的元素,如 Map 和 Set 等）\n\n数组去重合并:\n\n```\nfunction combine(){\n    let arr = [].concat.apply([], arguments);  //没有去重复的新数组\n    return Array.from(new Set(arr));\n}\n\nvar m = [1, 2, 2], n = [2,3,3];\nconsole.log(combine(m,n));   //[1, 2, 3]\n```\n\n### Array.concat(arr1, arr2, ...)\n\n可以同时连接多个数组，不修改原数组，所以`[].concat(arr1, arr2)`和`arr1.concat(arr2)`的效果是一样的。\n\n只是浅拷贝，会保留元素的引用。\n\n### indexOf() & lastIndexOf()\n\n与 String 的 indexOf() & lastIndexOf()方法一致\n\n### includes()\n\narr.includes(searchElement, fromIndex)：返回 true of false\n\n### Array.forEach()\n\n[Array.prototype.forEach()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\nforEach() 方法对数组的每个元素执行一次提供的函数。\n\n```\nvar array = [\"ab\", 'cd'];\nlet firstLetterUpperCase = [];\narray.forEach(function(item) {\n  firstLetterUpperCase.push(item[0].toUpperCase())\n});\nconsole.log(firstLetterUpperCase);\n```\n\n### reverse()\n\narr.reverse() 颠倒数组元素的顺序，修改原数组\n\n颠倒字符串的顺序\n\n```\nlet str = \"abcdefg\";\nconsole.log(Array.from(str).reverse().join(\"\")); //gfedcba\n// console.log(str.split(\"\").reverse().join(\"\")); //gfedcba   或者可以这样写\n```\n\n### sort()\n\narr.sort([compareFunction]): compareFunction 为可选参数，用来指定按某种顺序进行排列的函数。如果省略，元素按照**转换为的字符串**的各个字符的 Unicode 位点进行排序。返回排序后的数组。请注意，数组已原地排序，并且不进行复制。\n比较函数的格式如下：\n\n```\nfunction compare(a, b) {\n  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b\n    return -1;\n  }\n  else if (a > b ) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n```\n"},{"title":"SublimeText3 学习笔记","url":"/posts/12102/","content":"\n## 快捷键\n\n> [Sublime 配置心得](https://raw.githubusercontent.com/jikeytang/sublime-text/master/README.md)\n\n> [SublimeText3 常用快捷键和优秀插件](http://www.cnblogs.com/manfredHu/p/4941307.html)\n\n### 默认快捷键\n\n1. Ctrl+L 选择整行（按住-继续选择下行）\n2. Ctrl+Shift+K(shhift+del) 删除整行， ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首\n3. Ctrl+Shift+D 复制光标所在整行，插入在该行之前\n4. Ctrl+D 选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处\n5. Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）\n6. Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）\n7. Ctrl + alt + / 取消注释\n8. Ctrl+Shift+UP 与上行互换 ctrl + shift + up: 列模式编辑\n9. Ctrl + R 跳转当前页的目标方法\n10. Ctrl+K + U 大写\n11. Ctrl+K + L 小写\n12. 鼠标中间 列模式编辑\n13. Ctrl+Shift+[] 代码折叠\n14. ctrl+k ctrl+1: 折叠所有代码\n15. Ctrl + K,B 打开侧边栏\n16. ctrl + 回车：　　 光标后插入行，　 Ctrl+Shift+Enter 光标前插入行\n17. ctrl + m: 匹配括号\n18. vim mode 下 查找上一个下一个的快捷键是 是\\* #\n19. ctrl +z, y: 撤销，恢复撤销\n20. alt + .: 闭合当前标签\n21. Ctrl+F2: 设置书签\n22. F2: 下一个书签\n23. Shift+F2: 上一个书签\n24. ctrl + p: 即时的文件切换\n25. ctrl + shift + a: 选择标签内的内容\n26. ctrl + 单击： 多行随意位置添加光标\n27. alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词\n28. ctrl + F3: 跳转到下一个选中的词\n29. Ctrl+Shift+P Set Syntax:html : 设置文件类型\n30. Shift + 右键: 连续多行光标选中 (by Gary Gauh)\n\n### Emmet 快捷键\n\n1. match_pair_outward: ctrl+,向外匹配\n2. match_pair_inward: ctrl+alt+,向内匹配\n3. matching_pair: ctrl+alt+j，快速匹配 html 标签(phpstorm: ctrl + [])\n4. split_join_tag: shift+ctrl+`，快速成对修改 html 标签\n5. remove_tag: shift+ctrl+;删除包裹的 html 标签(phpstorm: ctrl + shift + del)\n6. increment_number_by_1: ctrl+up,数字快速增长,步长为 1\n7. decrement_number_by_1: ctrl+down,数字快速递减,步长为 1\n8. increment_number_by_01: alt+up,数字快速增长,步长为 0.1\n9. decrement_number_by_01: alt+down,数字快速递减,步长为 0.1\n10. increment_number_by_10:shift+alt+up,数字快速增长,步长为 10\n11. decrement_number_by_10: shift+alt+down,数字快速递减,步长为 10\n12. select_next_item:shift+ctrl+. 选择下一个属性\n13. select_previous_item: shift+ctrl+,, 选择上一个属性\n14. wrap_as_you_type: shift+ctrl+g,包裹内容\n\n### Vim 模式快捷键\n\n1. 移动：\n   h,j,k,l: 左，下，上，右。\n   w: 下一个词的词首。W:下一个单词(不含标点)。\n   e:下一个词的词尾。E:不含标点。\n   b:上一个词的词首。B:不含标点。\n   <>: v 模式选中后进行缩进。\n   `> > <<`:向前向后缩进。\n2. 跳转：\n   %: 可以匹配{},\"\",(),[]之间跳转。\n   H、M、L：直接跳转到当前屏幕的顶部、中部、底部。\n   #H：跳转到当前屏的第#行。\n   #L：跳转到当前屏的倒数第#行。\n   zt: 当前编辑行置为屏顶。\n   zz: 当前编辑行置为屏中。\n   zb: 当前编辑行置为屏底。\n   G：直接跳转到文件的底部。\n   gg: 跳转到文件首。\n   gd: 跳转到光标所在函数和变量的定义。\n   ():跳转到当前的行首、行尾。\n   {}：向上、向下跳转到最近的空行。\n   [{：跳转到目前区块开头。\n   ]}：跳转到目前区块结尾。\n   0: 跳转到行首。\n   \\$: 跳转到行尾。\n   `2$`: 跳转到下一行的行尾。 #：跳转到该行的第#个位置。\n   #G: 15G,跳转到 15 行。\n   :#：跳转到#行。\n   f'n'：跳转到下一个\"n\"字母后。\n   ctrl+b: 向后翻一页。\n   ctrl+f：向前翻一页。\n   ctrl+u: 向后翻半页。\n   ctrl+d: 向前翻半页。\n   ctry+e: 下滚一行。\n3. 选择：\n   1.v: 开启可视模式。 V: 开启逐行可视模式。\n   2.^V: 矩形选择。\n   3.v3w: 选择三个字符。\n   4.ab：包括括号和()内的区域。\n   5.aB：包括括号和{}内的区域。\n   6.ib：括号()内的区域。\n   7.iB：括号{}内的区域。\n   8.aw：标记一个单词。\n4. 编辑：\n   1. 新增：\n      i: 光标前插入。\n      I: 在当前行首插入。\n      a: 光标后插入。\n      A: 当前行尾插入。\n      O: 在当前行之前插入新行。\n      o: 在当前行之后插入新行。\n   2. 修改 c(change) 为主：\n      r: 替换光标所在处的字符。\n      R：替换光标所到之处的字符。\n      cw: 更改光标所在处的字到字尾处。\n      c#w: c3w 修改 3 个字符。\n      C：修改到行尾。\n      ci'：修改配对标点符号中的文本内容。\n      di'：删除配对标点符号中的文本内容。\n      yi'：复制配对标点符号中的文本内容。\n      vi'：选中配对标点符号中的文本内容。\n      s：替换当前一个光标所处字符。\n      #S：删除 # 行，并以新文本代替。\n   3. 删除 d(delete) 为主：\n      D：删除到行尾。\n      X: 每按一次，删除光标所在位置的前面一个字符。\n      x: 每按一次，删除光标所在位置的后面一个字符。\n      #x: 删除光标所在位置后面 6 个字符。\n      d^: 删至行首。\n      d\\$: 删至行尾。\n      dd:(剪切)删除光标所在行。\n      dw: 删除一个单词/光标之后的单词剩余部分。\n      d4w: 删除 4 个 word。\n      #dd: 从光标所在行开始删除#行。\n      daB: 删除{}及其内的内容。\n      diB: 删除{}中的内容。\n      n1,n2 d：将 n1,n2 行之间的内容删除。\n   4. 查找：\n      /： 输入关键字，发现不是要找的，直接在按 n，向后查找直到找到为止。\n      ?： 输入关键字，发现不是要找的，直接在按 n，向前查找直到找到为止。\n      `\\*`: 在当前页向后查找同一字。\n      #: 在当前页向前查找同一字。\n   5. 复制 y(yank)为主：\n      yw: 将光标所在之处到字尾的字符复制到缓冲区中。\n      #yw: 复制#个字到缓冲区。\n      Y：相当于 yy, 复制整行。\n      #yy:表示复制从光标所在的该行往下数#行文字。\n      p: 粘贴。所有与 y 相关的操作必用 p 来结合粘贴。\n      ]p：粘贴到合适的缩进处。\n      n1,n2 co n3：复制第 n1 行到第 n2 行之间的内容到第 n3 行后面。\n   6. 大小写转换：\n      gUU: 将当前行的字母改为大写。\n      guu: 将当前行的字母改为小写。\n      gUw: 将当前光标下的单词改为大写。\n      guw: 将当前光标下的单词改为小写。\n      a. 整篇大写:\n      ggguG\n      gg: 光标到文件第一个字符。\n      gu: 把选择范围全部小写。\n      G: 到文件结束。\n      b. 整篇小写：gggUG\n   7. 其它：\n      J：当前行和下一行合并成一行。\n   8. 移动：\n      n1,n2 m n3：将 n1 行到 n2 行之间的内容移至 n3 行下。\n5. 退出：\n   1. w filename: 保存正在编辑的文件 filename\n   2. wq filename: 保存后退出正在编辑的文件 filename\n   3. q：退出不保存。\n6. 窗口操作：\n   1. ctrl+w p: 在两个分割窗口之间来回切换。\n   2. ctrl+w j: 跳到下面的分割窗\n   3. ctrl+w h: 跳到左边的分割窗。\n   4. ctrl+w k: 跳到上面的分割窗。\n   5. ctrl+w l: 跳到右边的分割窗。\n7. 折叠：\n   zo 將游標所在處的折疊打開。open。\n   zc 將游標所在處已打開的內容再度折疊起來。close。\n   zr 將全文的所有折疊依層次通通打開。reduce。\n   zm 將全文已打開的折疊依層次通通再折疊起來。more。\n   zR 作用和 zr 同，但會打開含巢狀折疊（折疊中又還有折疊）的所有折疊。\n   zM 作用和 zm 同，但對於巢狀折疊亦有作用。\n   zi 這是個切換，是折疊與不折疊指令間的切換。\n   zn 打開全文的所有折疊。fold none。\n   zN 這是 zn 的相對指令，回復所有的折疊。\n"},{"title":"Git 学习笔记","url":"/posts/8520/","content":"\n## Commit message 格式化\n\n> 参考 [如何写好 git commit message](https://www.cnblogs.com/deng-cc/p/6322122.html)\n\n每次提交，Commit message 都包括两个核心部分：标题 和 内容。\n\n```\n<类型>(可选): <主题>\n2\n// 空一行\n3\n<内容>\n```\n\n其中，标题 是必需的，内容无需过多描述的话，正文内容部分可以省略。\n\n不管是哪一个部分，任何一行都不得超过 72 个字符（或 100 个字符）。这是为了避免自动换行影响美观。\n\n### commit 标题\n\n标题部分只有一行，包括字段：类型 和 主题。\n\n标题限制总字数在 50 个字符以内，以保证容易阅读。\n\n```\nfeat: init LearnGit.git\nI got a wrong-style git commit, so I init a .git for learning\nhow to write a git commit message in right way.\nAnd the last line just write here for a simple test,\nit's useless acturally.\n```\n\n#### 标题类型\n\n`类型`用于说明 commit 的类别，只允许使用下面 7 个标识。\n\n- init：项目初始化（用于项目初始化或其他某种行为的开始描述，不影响代码）\n- feat：新功能（feature）\n- add: 增加\n- fix：修补 bug\n- docs：文档（documentation）\n- opt：优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）\n- test：增加测试\n- save：单纯地保存记录\n- other：用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore 之类的可以使用）\n\n（可选）类型后面可以加上括号，括号内填写主要变动的范围，比如按功能模块分，某模块；或按项目三层架构模式分，分数据层、控制层之类的。 #：表示模块\n\n- #student --> 表示 学生模块 （具体的模块开头字母小写，驼峰命名）\n- #ALL --> 表示 所有模块 （特殊含义如 ALL 表所有，MOST 表大部分，用大写字母表示）\n- #MOST --> 表示 大部分模块\n\ne.g. feat(#student): 新增添加学生的功能 —— 表示 student 模块新增功能，功能是添加学生\n\n#### 标题主题\n\n主题 是 commit 目的的简短描述，不超过 50 个字符。\n\n- 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes\n- 第一个字母小写\n- 结尾不加句号（.）\n\n### commit 内容\n\n内容部分是对本次 commit 的详细描述，可以分成多行，正文在 72 个字符处换行。\n\n使用正文解释是什么(what)和为什么(why)，而不是如何做，以及与以前行为的对比。\n\n于是可以这样写：\nbalabala : balabala\n\nwhat:\nbalabala\n\nwhy:\nbalabala\n"},{"title":"JavaScript 基本数据类型","url":"/posts/438/","content":"\n## Number\n\n### 常规类型\n\nJS 中不区分`int`和`float`，无论是整数还是小数，其类型均为`Number`，在程序内部，`Number`类型的实质是一个 64 位的浮点数，因此 JavaScript 所能表示的数值范围为`±1.7976931348623157e+308`，其最小所能表示的小数为`±5e-324`，这两个边界值可以分别通过访问 Number 对象的 MAX_VALUE 属性和 MIN_VALUE 属性来获取。\n\n参考：[JavaScript 实验：数值范围](http://blog.shaochuancs.com/javascript-number-range/)\n\n### 特殊类型\n\n- `Infinity`：正无穷\n- `-Infinity`：负无穷\n- `NaN`：非数值\n\n## 字符串类型\n\n字符串类型用来表示文本数据，使用单引号或双引号来包裹起来表明此为字符串。\n\n字符串一旦创建就不能再次修改，但是可以基于对原始字符串的操作来创建新的字符串。\n\n## 布尔类型\n\n布尔类型的值只有两种：`true`和`false`。\n\nnull、undefined 在条件判断是都为`false`，其他值都为`true`，包括 0、-0、false、NaN、、或者空字符串（\"\"）。\n\n### 布尔类型比较\n\n## Null 类型\n\n`null`是缺少的标识，指示变量未指向任何对象，可以将`null`理解为尚未创建的对象。注意使用`typeof null`时会返回`object`，这属于历时遗留因素。\n\n## Undefined 类型\n\n一个没有被赋值的变量的类型是 undefined。如果方法或者是语句中操作的变量没有被赋值，则会返回 undefined。\n"},{"title":"《如何提问》阅读笔记","url":"/posts/13677/","content":"\n> [提问的智慧](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md)\n\n## 提问之前的准备\n\n### 检索现有资料\n\n在所有可能找到答案的地方\n\n- 搜索引擎\n- 手册\n- FAQ\n- 自己检查\n- 向身边朋友询问\n- 阅读源代码\n\n### 做好提问的准备\n\n- 组织好提问语言\n  * 精炼表述自己遇到的问题\n  * 表达清楚自己所做的尝试\n- 准备好报错信息\n\n## 在提问时\n\n### 利用好Stack Overflow\n\n- 在使用之前进行Google搜索\n- 在网站内部使用Tag等辅助搜索方式\n\n### 论坛提问\n\n- 仔细阅读论坛FAQ，谨慎选择提问的论坛，不要在论坛提出不合适的问题\n- 谨慎向私人或者论坛发送邮件\n\n### 邮件列表求组\n\n- 尽量向使用者或者维护者提问\n- 使用有意义且描述明确的标题：目标-差异\n  * 目标：哪一部分或哪一组东西有问题\n  * 差异：哪些部分与期望不一致\n- 认证对待语句，使用正确、清晰及精准的描述\n- 文件格式发送问题：\n  * 使用纯文本，不要使用封闭格式编写的文档\n  * 数据应该要保持原样\n  * 不要滥用表情符号和HTML其他功能\n\n### 有效的报告Bug\n\n- 仔细描述问题或者Bug症状\n- 附带bug运行环境：机器邮件配置、操作系统版本以及应用程序版本\n- 复述已经进行的操作尝试，以及你对问题的理解和研究\n- 确定问题的诊断步骤\n- 近期做过的可能引起bug的软件或硬件变更\n- 提供可复现bug的环境和方法\n\n## 描述清楚问题\n\n- 按时间先后列出问题症状\n- 先列出你的目标，再讲清楚你的过程\n- 询问代码相关问题时：精简代码，提供最精简的测试用例\n- 去掉无意义的语句\n- 不要用`紧急`等词汇\n- 尽量礼貌\n- 问题解决后增加补充说明\n\n## 合理使用搜索引擎\n\n- 一定要使用[Google](https://www.google.com)\n- 选择好正确的关键词\n- 学习搜索引擎命令大全，参考[知乎：如何用好谷歌等搜索引擎？](https://www.zhihu.com/question/20161362)"},{"title":"Markdown 基本语法总结","url":"/posts/39979/","content":"\n## 微小的建议\n\n- 标题、列表等标记符与正文文字之间应该有一个空格来分隔开\n- 不要吝啬使用回车，不同内容的文字块用回车来区分开来保证可读性，也能确保不同的Markdown解析器能正确解析，多余的回车也会被Markdown解析器自动忽略\n- 不同平台上的Markdown软件有着不同Markdown解析器，它们对基本的Markdown语法都有着很好的支持，但是作为产品特色也会对一些特殊的功能做一些私有的支持如流程图，可以事先查看不同的Markdown软件的说明\n\n## 标题\n\n用`#`来标记标题，从一到六共六级标题，`#`数越多，标题层级越低\n\n## 列表\n\n### 无序列表\n\n用`-`或`*`来标记，如：\n\n```\n- a\n- b\n* c\n* d\n```\n\n- a\n- b\n* c\n* d\n\n### 有序列表\n\n用`1.`、`2.`等 数字+. 的样式来表示，如：\n\n```\n1. a\n2. b\n3. c\n```\n\n1. a\n2. b\n3. c\n\n### 多级列表\n\n用缩进来表示层级关系，如：\n\n```\n- a\n    - b\n        - c \n            1. d \n```\n- a\n    - b\n        - c \n            1. d \n\n## 插入链接\n\n### 插入超链接\n\n用`[显示文字](链接)`来表示，如：\n\n```\n我的博客地址是：[Upside Down](https://kylindc.github.io/)\n```\n\n我的博客地址是：[Upside Down](https://kylindc.github.io/)\n\n### 插入图片\n\n用`![](链接)`来表示，如：\n\n```\n![](http://www.spoon-tamago.com/wp-content/uploads/2017/01/winter-2017-snowfall-kyoto-6.jpg)\n```\n\n![](http://www.spoon-tamago.com/wp-content/uploads/2017/01/winter-2017-snowfall-kyoto-6.jpg)\n\n## 引用\n\n用`>`来表示，如：\n\n```\n> 京都各个寺院的庭园，是日本人对艺术认识的最明确的宣言。因为，不论这庭园的结构，还是最具代表的桂离宫赏月台的景观，以及赏花亭对后面深山幽谷的模仿，都是极端的人工化对自然的巧妙的摹写，其中包藏着背叛自然的企图。自然与艺术作品之间，有着媚俗的隐秘的叛逆之心。艺术作品对自然的谋叛，犹如卖笑女子精神的不贞，阴柔而深切的虚伪，多以媚态的形式，装出一幅力图依偎自然而原封不动摹写自然的样子。 --三岛由纪夫《禁色》\n```\n\n> 京都各个寺院的庭园，是日本人对艺术认识的最明确的宣言。因为，不论这庭园的结构，还是最具代表的桂离宫赏月台的景观，以及赏花亭对后面深山幽谷的模仿，都是极端的人工化对自然的巧妙的摹写，其中包藏着背叛自然的企图。自然与艺术作品之间，有着媚俗的隐秘的叛逆之心。艺术作品对自然的谋叛，犹如卖笑女子精神的不贞，阴柔而深切的虚伪，多以媚态的形式，装出一幅力图依偎自然而原封不动摹写自然的样子。 --三岛由纪夫《禁色》\n\n## 粗体和斜体\n\n用`*文字*`标记斜体，用`**文字**`标记粗体\n\n## 代码引用\n\n### 文内应用\n\n用`要标记的代码`来标记，如：\n`console.log(Hello, World!)`\n\n### 代码块引用\n\n用三个`来标记，如：\n\n``` python\na = 'Hello, '\nb = 'World!'\nprint(a + b)\n```\n\n## 表格\n\n用`|`表示表哥竖线，用`---`表示表格标题行，用`:`位置来表示对齐方式，如：\n\n```\n| 学号  | 姓名  | 英语成绩 |\n| :---- | :---: | -------: |\n| 12345 | 张三  | 85       |\n| 23456 | 李四  | 88       |\n```\n\n| 学号  | 姓名  | 英语成绩 |\n| :---- | :---: | -------: |\n| 12345 | 张三  | 85       |\n| 23456 | 李四  | 88       |"},{"title":"羽毛球学习笔记","url":"/posts/18448/","content":"\n## 步伐\n\n### 前场步伐\n\n> 主要参考[月兔丨羽毛球 网前步伐剖析 怎么上网最适合你？](https://www.bilibili.com/av18614026/)\n\n\n* 正手上网步法\n    - 并步：两只脚都要发力去蹬\n    - 交叉跨步：左脚先动\n    - 后交叉：\n    - 垫步：左脚迈出去够不到，左脚再垫一步\n* 反手上网步伐\n    - 跨步：左脚先动，上前跨一小步，右脚再上前一大步\n    - 并步：右脚直接并步上网\n* 步法回动：右脚在前\n* 正反手步法衔接：最后一步变成下一个步法的启动\n\n## 杀球\n\n* 握拍：球拍从虎口对齐握法转动10°左右，以便排面正对击球\n\n## 双打\n\n> 主要参考[李在福的双打教学视频](https://www.bilibili.com/av12742547)\n\n### 发球\n\n#### 反手发网前小球\n\n* 持球手同边脚在前\n* 食指和拇指捏住一根羽毛\n* **球头指向膝盖，大约45°**，球头垂直地面容易过高，反之则容易下网\n* 手腕挥拍，而不是手臂\n* 整个身体向上，显示出自己的自信\n* **80%发中场球，发边线球时在击球时改变拍面**\n\n#### 发球后处理\n\n* 用启动步方式回到中场位置，**双脚同时落地**\n* 发完球后，不要躲在网下，直起背，宽阔视野，**举起拍子**主动寻找拦截和扑网的机会，负责整个网前球\n\n#### 正手发远球\n\n* 发球后回退变成平行站位，侧身站，身体面向球的位置，而不是跟网面平行；球拍指向球的位置，不要太接近于反手，不利于正手接球\n* 发球后站位：发球人后退，队友上前，防守站位；发球人可稍靠前一些，队友稍站后一些，尽量与球的位置形成等腰三角形\n\n### 网前扑球\n\n#### 发球方网前扑球\n\n* 击球时不要向后引拍，可以提前拉后一点，然后击球时用寸劲，急促发力，点杀\n\n#### 接球方网前扑球\n\n* 接球准备时，左脚在前，侧身站位\n* 对方发球时，双脚启动步，注意判断对方球路\n* 右脚上前扑球\n* 回到中场，双脚并排站位\n* 若本身站位比较靠前，则直接扑球，不需要右脚上前\n\n### 双打站位\n\n* 轮换站位，两人始终运动方向相反\n* 及时补位\n\n### 接杀对墙练习\n\n* 容易忽视的三点：步法；球拍的位置；姿势\n* 步法：时刻准备好启动步\n* 球拍位置：稍微远离身体一些\n* 姿势：降低重心；将身体作为一个整体\n* 正反手交叉练习\n* 直线斜线交叉练习  \n\n### 双打防守技巧\n\n* 尽量使用反手回球\n\n## 杀球\n\n> 主要参考[李矛 教你如何杀球! 万恶之源 手肘慢!](https://www.bilibili.com/av15707185/)\n\n* 可从前场杀球开始练习，熟练后慢慢往后场靠\n* 不要抡（过渡向后引拍），而要挤（寸劲发力，短促发力）","tags":["羽毛球"]},{"title":"plan B","url":"/posts/51724/","content":"\n## 客户端选择及下载\n\n### Windows 客户端\n\n[ShadowsocksR](https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases)\n\n### Android 客户端\n\n[ShadowsocksR-Android](https://github.com/shadowsocksrr/shadowsocksr-android/releases)\n\n### iOS 客户端\n\n国区：ShadowProxy(随时有下架的风险)\n美区：Shadowrocket、Wingy、Potatso Lite 等等\n\n### MacOS 客户端\n\n[ShadowsocksX-NG-R](https://github.com/qinyuhang/ShadowsocksX-NG-R/releases)\n[clashX](https://github.com/yichengchen/clashX/releases)\n\n## ShadowsocksR\n\nSSR IP 地址那一栏主要分为两种，一个是域名，一个是纯 IP 地址，其实后台都是同一个，用域名做地址的好处是后台换了的话，大家也不用修改什么，缺点大概就是要一年换一次，因为域名续费太贵了。\n\n下面是用域名做地址的服务器（推荐使用这个）\n\n![](xyz-443-d71629fb4b9d38440f2e964e91c20ab2.png)\n\n下面是直接用 IP 做地址的服务器\n\n![](GIA-3824-06671c02e768fe251ca907ea1878acda.png)\n\n## Shadowsocks\n\n这个是直接用 IP 做地址的服务器的 SS，因为有些客户端不支持 SSR，可以使用这个\n\n![](GIA-5555-1eafd48945b10a8630c6d274f3051a4c.png)\n\n还可以到[免费上网账号](https://free-ss.site/)找临时号使用，但是这个站本身也是被墙了的，可以发邮件到客服邮箱 ss at rohankdd dot com 自动获取免翻镜像站\n","tags":["杂"]},{"title":"点亮你的 PPT 封面","url":"/posts/37763/","content":"\n> 这个本来是我上个学期上英语课所做的 presentation。本来主题都是自定介绍一些自身相关领域论文的学术报告，但当时老师突然说找几个人来做一下与 PPT 制作相关主题的 presentation，然后我就自告奋勇选择了 PPT 封面制作的主题。考虑到主要的介绍领域还是学术类的 PPT ，所以还是选择了 4:3 作为 PPT 页面的比例，同时也尽量使用系统自带的字体（以微软雅黑和 Arial 为主）。不过也做了几张比较「浮夸」的封面，并不适合严肃场合，只是为了好玩。\n\n\n## 内容介绍\n\n快是一年前做的东西了，很多都不记得了。\n\n大概介绍了一下：\n\n* 全图型封面\n* 上下布局的半图型封面\n* 左右布局的半图型封面\n* 斜切式半图封面\n* 利用形状做的封面\n\n## PPT 在线展示\n\n<iframe src=\"https://onedrive.live.com/embed?cid=35D50D4F86295DC0&resid=35D50D4F86295DC0%2111777&authkey=APlKlDYqFD47Rt8&em=2\" width=100% height='360' frameborder=\"0\" scrolling=\"no\"></iframe>","tags":["设计","PPT"]},{"title":"关于《西文排版》","url":"/posts/42892/","content":"\n> 本文是看了[《西文排版：排版的基础和规范》](https://book.douban.com/subject/26834548/)之后做的一些笔记，把自己觉得新奇的点记了下来做一些笔记，也加上了一些特殊样式在 PS 和 Word 中的实现。\n\n## 小型大写字母\n\n> 小型大写字母（英语：small capitals，简称 small caps）是西文字体设计中的一种字符形式。这些字母的形状（字形）和大写字母相同但尺寸较小。一般来说，小型大写字母的高度等于一个 x 字 高，和大部分的小写字母一样；只有在极个别字体中，小型大写字母的高度会比 x 字 高略高一些。[^1]\n\n### 小型大写字母的用途\n\n维基百科上给出了一些常用的用途，不过不必拘泥于此，在商标、标题、名片上的人名、公司名都可以尝试试一试。小型大写字母的字距要拉大一些，可以提升美感，显得更加优雅一些。\n\n用小型大写字母字母来显示公司名字：\n\n![](small-caps-9b1fe572069d5c2693b7644e9b47db23.jpg)\n\n#### 在人名上的应用\n\n和西方不一样，中国人和日本人的姓名都是姓在前，名在后。但是用英文表示名字的时候，到底是根据自己的习惯来姓在前，还是按照英语的习惯名在前，可能都没有一个确定的说法，很容易引起误会（尤其是日本人用复姓居多，使用罗马音拼出来更加分不清）。这个时候可以用小型大写字母来表示姓，这样就不会产生歧义。例如：\n\n<span lang='ja'><ruby><rb>福沢</rb><rp>（</rp><rt>ふくざわ</rt><rp>）</rp></ruby><span lang='ja'><ruby><rb>諭吉</rb><rp>（</rp><rt>ゆきち</rt><rp>）</rp></ruby>的英文名字即为：<span style=\"font-variant: small-caps;\">Fukuzawa</span> Yukichi\n\n这样就很容易看出是姓在前而名在后。\n\n#### 生活上的其他语法\n\n了解了「小型大写字母」这个概念之后发现生活中经常出现这种用法。\n\n比如我贴的墙壁贴纸：\n\n![](small-caps-wallpaper-dd049d429eae782cf49bc2f0c46b1ddb.jpg)\n\n比如美剧《硅谷》第四季中某集中用小型大写字母写人名来表示强调，而且这也是在手写中的应用例子：\n\n![](small-caps-tvs-28eb534593a8f4596415ea83a32e4271-8564385c472e002ddaa7d333bf5e9a07.jpg)\n\n### 小型大写字母的实现\n\n#### 在网页上的实现\n\n使用以下语法即、可在网页上实现：\n\n```html\n<span style=\"font-variant: small-caps;\">Fukuzawa</span> Yukichi\n```\n\n实现效果如下：\n\n<span style=\"font-variant: small-caps;\">Fukuzawa</span> Yukichi\n\n#### 在 PS 里的实现\n\n在 PS 中只要在字体面板选择字符样式第一排第四个即可。\n\n![](small-caps-ps-52518e551f844dd07ea5b92fb40f704d.jpg)\n\n#### 在 Word 中的实现\n\nWord 中只要在字体面板字体选项卡中勾选上「小型大写字母」就好。\n\n![](small-caps-word-90507098bd9c7388c57f7b3a925f9296.jpg)\n\n## 旧式数字\n\n旧式数字（Text figures, Oldstyle Figures, 不齐线数字，老式数字）与等高数字（Lining figures， 齐线数字）向对应，指的是中世纪风格的一种数字底部不平行的一种数字风格，常常出现在一些古典的、正式的风格中。\n\n### 旧式数字的实现\n\n#### 在 PS 中的实现\n\n在 PS 中实现旧式数字有些麻烦，首先要勾选上「文字 - OpenType -旧样式」，再键入数字，这是针对本身带有旧式数字的字型，要是本身不带有旧式数字，也没办法显示出来。还有一种情况就是要是某个字型默认显示的是旧式数字，我暂时还没看到强制使用等高数字的办法。\n\n![](old-figure-ps-01ec44513bd86d06c92a3609a8d12005.jpg)\n\n#### 在 Word 中的实现\n\nWord 中只要在字体面板高级选项卡中「OpenType 功能」中「数字样式」中选择「旧样式」就好。\n\n![](old-figure-word-4f884d36707b81b9b9c1d7f0039e428b.jpg)\n\n更多关于数字的更多样式可以听听[字谈字畅 056：数，不胜数 (1)](https://www.typeisbeautiful.com/2017/09/13460/)。\n\n## 字偶间距、字符间距和词间距\n\nPS 中将光标放到两个字母之间再使用快捷键 `Alt + ←/→` 可以调节两个字母之间的间距，这个间距被称为字偶间距（Kerning，字偶距），由于不同字母的形状，字母组合之间的距离需要调整来达到完美的组合效果。\n\n只要留意的话，生活中还是经常可以看到需要调节字偶距的地方，比如我一个经常吃煲仔饭的店子里的装饰：\n\n![](Kerning-3f223611fdd1adebcaa4c04d7c92aed5.jpg)\n\n仔细看的话其中有些字母的间隙还是可以微调的。\n\n也可以通过到 [Kerntype](http://type.method.ac/) 去尝试感受字偶距的魅力。\n\n字符简距（Letterspacing, Tracking, Character Spacing, 字距）更加强调的是整行文字中字母之间的间隙。\n\n词间距（Word Spacing）指的是各个单词之间的距离。\n\n以上三个概念还是很容易搞混淆的。\n\n如图在 PS 字符面板中，蓝色线表示的是字偶间距，绿色线表示的是字距。\n\n![](kerning-ps)\n\n## 「河流」与「街道」\n\n「河流」与「街道」均指的是排版中出现的，在相邻多行内，由标点符号或西文单词之间的空格所产生的空白区域连成了一条斜线（river）或者竖线（street），这些空白区域会影响阅读，是要在排版过程中要避免的。\n\n这是我考科目二在考场看到的感谢信中出现的中文排版里的 'river' 现象：\n\n![](river-d1249532a169f1f91bc3d9d5bf1d264d.jpg)\n\n## 标点悬挂\n\n标点悬挂指的是由于标点「避头」的原则，若按正常字距处理的话，该标点将会超出该行右对齐的基线，传统办法是将此行进行压缩，即减少字距，使得该标点处在右对齐基线以内。标点悬挂则不处理字距，将该标点继续放置在基线以外。这种做法在日文排版中较常见，中文排版中正在慢慢流行。\n\n下图为央视所使用的标点悬挂[^2]（效果并不完整，第二行还是有进行压缩）:\n\n![](标点悬挂-央视-4de6164f23d713992a029c206ed287ad.jpg)\n\n### Word 中开启标点悬挂\n\n1. 段落-中文版式-换行-允许标点溢出边界\n2. 段落-中文版式-字符间距-选项-字符间距控制-不压缩\n\n## 行长\n\n中文排版的优化与纵横对齐\n\nType is beautiful 的文章：[从「行长为字号的整数倍」说起](https://www.typeisbeautiful.com/2017/07/12513/)\n\n突然发现「端」客户端就是这样做的\n\n## 排版优化\n\n- 合理使用旧式数字\n- 使用意大利斜体来表示强调\n- 小标题位置不应该在段落正中央\n- 使用 'fi' 'ff' 'ffi' 等合字\n- 区分使用角分符和缩略号\n- 行首不能有冒号、句号等标点符号\n- 段首缩进要彻底\n- 不到 100 的数字还是拼写出来比较好\n- 括号之前需要一次字距的空格\n- 区分使用连字符和连接号\n- 段落最后一行应避免剩下一个单词\n- 注意孤行控制\n- 标题应该避免出现在页面较低的位置\n- A, I, He 等不影响行长的单词应该放到下一行比较好\n- 注意段首缩进样式\n\n## 引用\n\n[^1]: [小型大写字母 - 维基百科](https://zh.wikipedia.org/wiki/%E5%B0%8F%E5%9E%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D)\n[^2]: [@文川溪畔东瀛居：央视也会用标点悬挂](https://weibo.com/1408763553/FjKpF3BR2)\n","tags":["字体","书","设计"]},{"title":"作画学习札记其六：关于动画的一些讨论","url":"/posts/63201/","content":"\n\n每看到一篇关于介绍作画的文章，都会介绍到关于「金田系」及「宇都宫系」\n\n\n\n\n\n<link href='https://www.hanyi.studio/WebFonts/C3DB971E-443B-4D37-887D-530EE441EB6B/201708/css/620581D445F9FE65.css' rel='stylesheet' type='text/css'/>\n<div class=\"css620581D445F9FE65\">汉仪新人文宋</div>\n\n\n\n\n\n\n\n作画与监督的关系\n\n作画与演出的关系\n\n作画与分镜的关系\n\n\n动画人时间\n\n黑客帝国动画版\n\n\n## 金田系\n\n## 写实系\n\n\n## Web系\n\n\n\n## 研究作画的意义\n\n\n## 动画与电影的关系\n\n\n## 作画资源\n\nsakugabooru\n\n博客 \n\nsakugablue\n\n作画wiki\n\naniatama\n\n\n## 引用\n\n1. [作画讲座：日式作画与幕后的动画师们（13版）](https://www.bilibili.com/video/av913002/)\n2. [日式作画基础解说 完整版](https://www.bilibili.com/video/av2251266/)\n3. [解新番第二十四期：中村丰到底有多厉害？](https://www.bilibili.com/video/av12024948/)"},{"title":"作画学习札记其五：新生力量篇","url":"/posts/46471/","content":"\n### 黄成希\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/ddf8d3ac7ee936d06916433f3f4b2f44.webm' %}\n\nhttp://www.anitama.cn/series/196/\n\n\n\n### 梁博雅\n\n叉烧希（非常想吃叉烧的希）\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/a80b984519eaa53bb4271b2745b57743.mp4' %}\n\nhttp://www.anitama.cn/series/18/\n\n\n### Bahi JD\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/6b7ac6ea617cf94140ffc50e699a7842.mp4' %}\n\n来自奥地利的原画师，好像以前只是在网上制作 gif ，最终融入日本主流作画界，本身也是相当励志\n\n有参与《太空丹迪》、《乒乓》制作\n\n节选视频出自《银翼杀手：2022大断电》，完整视频移步：[银翼杀手2022（中字）](https://www.bilibili.com/video/av14840910/),相当炸裂，作画厨的狂欢\n","tags":["动画","作画"]},{"title":"作画学习札记其四：中流砥柱篇","url":"/posts/31648/","content":"### Ryo-timo（泽良辅）\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/876f255eb05b9b30283346b9aff92410.webm' %}\n\n\n\n\n### 山下清悟\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/4a512f1609658555c083a033a3b9be2e.webm' %}\n\n\n### 佐藤雅弘\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/5e9390795e5db8b04f43928911d910bb.mp4' %}\n\n异邦人  初战  长枪\n\n### 向田隆\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/0f09cf9f2a1e8feb87e563b431b81cb2.mp4' %}\n\n两个向田回旋踢\n\n格斗棒\n\n\n### 金世俊\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/82acc7da4cd71d4277ac960c950fe83d.mp4' %}\n\n马戏  高达\n\n\n### 竹内哲也\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/de47143ceef6eb00ae38eff303414ac9.webm' %}\n\n\n\n片段是zero\n\nubw 主力 <del>特技</del>特效作画\n\n\n### 山下宏幸\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/d5b9145b3260fef1751cb985cd5fd19c.mp4' %}\n\n### 久贝典史\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/fc4cc5a1ac06fce16d1a2d5927ee27e5.mp4' %}\n\n太空丹迪\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/d4d2f2864b9c56845f426c550188081f.mp4' %}\n\nhttp://www.anitama.cn/article/7d36841e7510af6b\n\n\n### 桥本敬史\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/c3b5794fa09460cdbce495ed93f0d9e6.mp4' %}\n\n爆炸狂魔\n\n### 今井有文\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/eb0b59a12d86695f3e3bcce79d98cc30.mp4' %}\n\n### 阿部望\n\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/f43abc853498ec6fde9e2b2a50bd45c7.webm' %}\n\n\n\n### 西尾铁也\n\n{% mmedia \"dplayer\" 'url=' %}\n\n火影班\n\n\n### 森本晃司\n\n{% mmedia \"dplayer\" 'url=' %}\n","tags":["动画","作画"]},{"title":"作画学习札记其三：暴强老害篇（2）","url":"/posts/56037/","content":"\n### 汤浅政明\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/36afeb971bbe9c9dc401b2d68484b2e7.mp4' %}\n\n<iframe src=\"https://www.bilibili.com/html/html5player.html?aid=4633569&cid=7517335&as_wide=1\" width=\"100%\" height=\"410\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n\n混沌武士  飞叶子一段\n\n乒乓  最后一集扔拍子一段\n\n欢迎来到宇宙秀\n\n\n### 吉成曜\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/54bb5cc3153a2298ee359a96c9b49bf9.mp4' %}\n\n\n### 龟田祥伦\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/e0a761d4e6144a1e841cb234ff49b998.webm' %}\n\n\n### 田中宏纪\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/0578b5e7af87cb467bb17204796196b4.webm' %}\n\n### 村木靖\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/7c4bf130d906df0c80b768318b53ef10.webm' %}\n\n马戏\n\n### 后藤雅巳\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/7a8875b2742961419b1895f5dc8bfb55.mp4' %}\n\n星际牛仔\n\n### 吉成钢\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/e9e56f444fb1a6d299db53205e740244.webm' %}\n\n\n### 矶光雄\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/39cd74db8d52543043d7244928341715.webm' %}\n\n### 中泽一登\n","tags":["动画","作画"]},{"title":"作画学习札记其二：暴强老害篇（1）","url":"/posts/6919/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=240 src=\"//music.163.com/outchain/player?type=0&id=876460941&auto=0&height=430\"></iframe>\n\n### 中村丰\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/d2285022e82f02675f6db07a62fecd79.mp4' %}\n\n这里是中村丰在《灵能百分百》中的一段。下坠过程中特写镜头切远景后镜头极速后拉升，帅到爆炸。接近地面时一连串升格镜头蓄力，黑白闪，高速运动下变形的脸的大特写，坠地后再用全景的「中村方块」和远景的黑白闪来体现坠地的重量感以及绝对的力量差距。\n\n中村有名的片段非常多，包括《星际牛仔：天国之扉》车厢内打斗一段、《异邦人：无皇刃谭》最后结尾无名VS黄毛一段（这段简直就是教科书般的存在了，我每看一个介绍作画的视频都会提到它）。还有一个片段，中村丰仅用了 3 张（1/8秒）就表现出人物从远景越过镜头，简直就是快到爆炸。[@nbht](http://weibo.com/lmnbht \"nbht的新浪微博\") 专门做过[一期视频](https://www.bilibili.com/video/av12024948/ \"解新番第二十四期：中村丰到底有多厉害？\")来介绍了中村丰的各种厉害之处，指明了吹「国宝」的正确方向。\n\n### 大平晋也\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/cff08e0868e00b236ce6cbe5c8a8f378.webm' %}\n\n这一段是《黑客帝国动画版：少年故事》里的一段，在取出滑板之前都是由桥本晋治画的。\n\n参与宫崎骏\n\n### 今石洋之\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/5aae2659d1a508718462c6b1655484aa.mp4' %}\n\n### 松本宪生\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/573d9b41bb6c9e6ea017e173ed447443.mp4' %}\n\n### 桥本晋治\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/581cec3856380d0b3029bff88ffd647c.mp4' %}\n\n这一段同样出自《黑客帝国动画版：少年故事》，桥本晋治也是这一集的导演，除了上面提到的那一卡，应该有\n\n### 安藤真裕\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/876ba72aa5f1d6d2ced5219cff4e4581.mp4' %}\n\n### 小池健\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/bb34c6a137ec697e9194f211d89f543f.mp4' %}\n\n世界纪录\n\n\n\n### 井上俊之\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/4e4914d820817b1918f4eb7002af830f.mp4' %}\n\n\n\n### 冲浦启之\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/f09c51631f656c50bb7222ced4b4f2b5.webm' %}\n\n\n\n\n\n","tags":["动画","作画"]},{"title":"作画学习札记其一：作画基本概念及开山始祖篇","url":"/posts/16014/","content":"> 本系列是关于马小褂老师翻译的[作画讲座：日式作画与幕后的动画师们（13版）](https://www.bilibili.com/video/av913002/)一些笔记，并且补充上自己所搜集的一些资料，本意是做一下这段时间接触日式作画的一个总结，也可以作为初步了解日式作画及老害原画师的一个索引。无特别强调，后文「动画」一词特指「日本动画」，「作画」一词特指「日式作画」。\n.\n> 开山始祖：指对动画史造成很大影响且现在已经不在作画一线的人。\n暴强老害：就是一些很强的高手嘛。\n中流砥柱：就是一些马上就会成为老害的人嘛。\n新兴力量：就是一些马上就会成为中流砥柱的人嘛。\n.\n>引用视频巨多，建议在 WI-FI 下观看。由于B站外链显示不正常缘故，建议在电脑上阅读；手机建议横屏观看B站外链视频。\n\n\n## 作画基本概念\n\n### 什么是作画？\n\n首先澄清一个概念——「帧数」，在B站看番的时候看到一些华丽流畅的场面，就会出现很多弹幕——「帧数爆炸」，「经费爆炸」，其实动画是没有什么帧数区别的，基本都是**24帧/秒**，这个数值是由电视信号参数决定的，不存在「帧数爆炸」一说。没有**帧数**的区别，但是有**张数**的区别。\n\n毫无疑问，动画都是由一张张的静止的画面构成的（暂时不考虑 3D 作画），如果某段动画中每秒由24张**不同**的画面组成，那么这段动画被称为**一拍一**作画，或者称为**1k**作画，同样，如果某段动画中每秒由24/2=12张**不同**的画面组成，那么这段动画被称为**一拍二**作画，或者称为**2k**作画。以此类推有3k，4k等等。EVA 中第24集有一段64秒静止画面，所以就是 24*64=1536k 作画（痞子庵：我有特别的省钱技巧）。\n\n每秒动画中不同画面的数量也被称为「张数」。张数是影响动画是否流畅的一个因素，张数上来了，动画自然也就觉得流畅了。张数是一个因素，原画师的功劳则是另一个因素。\n\n\n### 动画制作流程\n\n首先简单介绍下动画制作的主要流程：\n\n> 脚本 -> 分镜 -> Layout -> 原画 -> 原画检查 -> 动画 -> 动画检查 -> 色彩、摄影、特效 -> 本摄\n\n<span lang='ja'><ruby>原画<rp>（</rp><rt>げんが</rt><rp>）</rp></ruby></sapn>意为「关键帧绘制」，指的是绘制动画中每卡的关键姿势或者关键位置，<span lang='ja'><ruby>動画<rp>（</rp><rt>どうが</rt><rp>）</rp></ruby></sapn>意为「中间帧绘制」，动画负责原画之间的流畅运动。其中「中间帧」也被称为<span lang='ja'><ruby>中割り<rp>（</rp><rt>なかわり</rt><rp>）</rp></ruby></sapn>。\n\n原画和动画统称为<ruby><span lang='ja'>作画<rp>（</rp><rt>さくが</rt><rp>）</rp></ruby></sapn>（ Sakuga，这已经成为了一个英文词）。\n\n由于原画师对动画有很强的控制力以及效果好坏在作画程度主要取决于原画师，所以一般在讨论作画是都指的是原画的好坏。实际情况下讨论「作画」的时候都是在讨论「出色作画」。\n\n### 作画基本概念\n\n* 张数：动画都是由一张张的静止的画面构成的（暂时不考虑3D作画）。动画中不存在「帧数」这个说法，因为绝大多数动画都是 24帧/秒，这是由电视台信号参数决定的。所以也就不存在所谓的「帧数爆炸」。如果某段动画中每秒由 24 张**不同**的画面组成，那么这段动画被称为**一拍一**作画，或者称为 **1k** 作画，同样，如果某段动画中每秒由 24/2=12 张**不同**的画面组成，那么这段动画被称为**一拍二**作画，或者称为 **2k** 作画。以此类推有 3k，4k 等等。EVA 中第 24 集有一段 64 秒静止画面，所以就是 24*64=1536k 作画（痞子庵：我有特别的省钱技巧）。每秒动画中不同画面的数量就被称为「张数」。\n\n* 造型：指人、物肢体运动的形状。\n\n* 轨道：包括肢体、运动、镜头的轨迹。有些机战番中会画出导弹飞行时划过的痕迹（也被称为「马戏」），这就是轨道的一种。\n\n* 踩点：原画时间间隔（1/24 秒、2/24 秒等等）下运动在轨道上的投影点。\n\n以上只是对作画基本概念的一些简单阐述，由于文字的局限性，这些概念结合视频会更加容易理解，推荐视频[日式作画基础解说 完整版](https://www.bilibili.com/video/av2251266/)。\n\n\n## \n\n### 宫崎骏\n\n\n\n### 金田伊功\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/d9e8569dfcfccd3b4a2a463e9e7680a1.mp4' %}\n\n### 中村孝\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/a0e58bf98eac5704f80aa08bf91b2b8a.mp4' %}\n\n### 宇都宫理\n\n{% mmedia \"dplayer\" 'url=' %}\n\n\n### 庵野秀明\n\n{% mmedia \"dplayer\" 'url=' %}\n\n\n### 板野一郎\n\n{% mmedia \"dplayer\" 'url=' %}\n\n\n### 安藤雅司\n\n{% mmedia \"dplayer\" 'url=https://sakugabooru.com/data/14c8dca734ca530f034fbb91fc71ebad.mp4' %}\n","tags":["动画","作画"]},{"title":"Hexo 折腾手记其三：多媒体及互联网资源插入博客","url":"/posts/53723/","content":"## 插入图片\n\n为了方便文章插图管理，首先在 `_config.yml` 中将 `post_asset_folder` 设为 `true` 后，\n\n``` yml\npost_asset_folder: true\n```\n\nHexo 会在以后的新建文章时就会自动在与文章同一文件夹下新建与文章同名的文件夹，将文章的所有插图发在此文件夹里，就使用相对路径引用图片资源了。\n\n``` markdown\n![](image.jpg)\n```\n\n不过这只是Markdown的引用方式，图片只会在文章中显示而不会在首页中显示，若希望图片在文章和首页中都正常显示，需要使用标签语法。\n\n``` html\n{% asset_img example.jpg This is an example image %}\n```\n\n以上内容参考Hexo官方文档[Hexo 官方文档-资源文件夹](https://hexo.io/zh-cn/docs/asset-folders.html)。\n\n## 插入视频\n\n### 使用 HTML5 video 标签插入\n\n``` html\n<video src=\"example-a80b984519eaa53bb4271b2745b57743.mp4\" height=498 width='100%' controls=\"controls\">\n</video>\n```\n\n使用效果如下：\n<video src=\"example.mp4\" height=498 width='100%' controls=\"controls\">\n</video>\n\n更多参数设置请参考[W3school-HTML `<video>` 标签](http://www.w3school.com.cn/tags/tag_video.asp)。\n\n### 使用 HTML5 iframe 标签插入\n\n``` html\n<iframe src=\"example.mp4\" height=360 width='100%' controls=\"controls\" allowfullscreen></iframe>\n```\n\n效果如下：\n\n<iframe src=\"example.mp4\" height=360 width='100%' frameborder=0 controls=\"controls\" allowfullscreen></iframe>\n\n更多参数设置请参考[W3school-HTML `<iframe>` 标签](http://www.w3school.com.cn/tags/tag_iframe.asp)。\n\n注意以上两个标签都可以通过参数 `height` 和 `width` 来控制大小。\n\n### 通过 hexo-dplayer 插件插入视频\n\n首先安装 [**Dplayer**](https://github.com/NextMoe/hexo-tag-dplayer)插件，通过以下方式使用插件：\n\n``` html\n{% mmedia \"dplayer\" \"url=example.mp4\" %}\n```\n\n效果如下：\n\n{% mmedia \"dplayer\" \"url=example.mp4\" %}\n\n这种方式使用起来最快捷、最方便，而且功能也很强大。\n\n### 视频格式注意事项\n\n并非所有的视频格式都被浏览器所支持，以下表格参考[W3cshool](http://www.w3school.com.cn/html5/html_5_video.asp):\n\n| 格式 | IE | Firefox | Opera | Chrome | Safari |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| Ogg | No | 3.5+ | 10.5+ | 5.0+ | No |\n| MPEG-4 | 9.0+ | No | No | 5.0+ | 3.0+ |\n| WebM | No | 4.0+ | 10.6+ | 6.0+ | No |\n\n正是由于格式的限制，所以还是推荐用插入视频网站外链的方式来插入视频，具体见后面的文章。\n\n## 插入音频\n\n### 可以通过 HTML5 标签插入\n\n``` html\n<audio src=\"Tune for a Found Harmonium-4b138651b9eba10167e2e035246bf95c.mp3\" controls=\"controls\">\n</audio>\n```\n\n效果如下\n<audio src=\"Tune for a Found Harmonium.mp3\" controls=\"controls\">\n</audio>\n.\n\n### 通过 hexo-aplayer 插件插入\n\n首先安装 [Aplayer](https://github.com/MoePlayer/hexo-tag-aplayer) \n\n通过以下方式插入音频：\n\n```\n{% mmedia \"aplayer\" title author url %}\n```\n\n使用效果如下：\n\n{% mmedia \"aplayer\" \"Tune for a Found Harmonium\" \"Phil Coulter\" \"Tune for a Found Harmonium.mp3\" %}\n\n### 音频的格式限制\n\n同样，浏览器对音频也有严重的格式限制，具体参考[W3school](http://www.w3school.com.cn/html5/html_5_audio.asp)如下：\n\n| 格式 | IE 9 | Firefox 3.5 | Opera 10.5 | Chrome 3.0 | Safari 3.0 |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n| Ogg Vorbis |  | √ | √ | √ |  |\n| MP3 | √ |  |  | √ | √ |\n| Wav |  | √ | √ |  | √ |\n\n\n可见音频插入效果有多糟糕，所以同样还是推荐使用互联网服务吧。\n\n## 插入互联网资源\n\n### 插入B站外链\n\n使用下面的模版\n\n``` html\n<iframe src=\"https://www.bilibili.com/html/html5player.html?aid=6128931&cid=12758570&as_wide=1\" width=\"100%\" height=\"410\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n```\n\n注意事项：\n1. 右键你想插入的B站视频页面，选择查看网页源代码，然后`Crtl+F`搜索`cid`，大概在410行左右，就可以找到`aid` 和 `cid` 两个参数，然后替换进上述模版。\n2. 参数`&as_wide=1`会使视频自动隐藏侧边栏，但会在移动设备上显示不正常，所以视情况取舍加或不加。\n\n使用效果如下：\n\n<iframe src=\"https://www.bilibili.com/html/html5player.html?aid=6128931&cid=12758570&as_wide=1\" width=\"600\" height=\"410\" frameborder=\"0\" webkitallowfullscreen='true' mozallowfullscreen='true' allowfullscreen='true' frameborder=\"0\"></iframe>\n\n### 插入网易云音乐歌曲或歌单外链\n\n找到歌单或歌曲播放页面，点击`生成外链播放器`，选择好尺寸后，再把代码粘贴好就行了。\n\n\n``` html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=411315632&auto=0&height=66\"></iframe>\n```\n\n效果如下：\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=411315632&auto=0&height=66\"></iframe>\n\n### 插入 YouTube \n\n视频页面 -> 分享视频 -> 嵌入 -> 选择开始时间（可选） -> 复制 -> 粘贴进文档\n\n复制后的模版如下：\n\n``` html\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/NasyGUeNMTs\" frameborder=\"0\" allowfullscreen></iframe>\n```\n\n或者参考 Hexo 官方文档，用如下方式也可以：\n\n```\n{% youtube video_id %}\n```\n`video_id`就是 YouTube 播放页面地址最后一点奇奇怪怪的字母数字组合。\n\n两种方式效果都差不多，可能第二种自适应网页的程度会更高一些，因为不用手动调大小。\n\n效果如下：\n\n{% youtube NasyGUeNMTs %}\n\n\n### 插入推文\n\n#### 推特提供的方式\n\n要插入的推文 -> 右上角倒三角形 -> 嵌入推文 -> 复制代码 -> 粘贴\n\n``` html\n<blockquote class=\"twitter-tweet\" data-lang=\"zh-cn\"><p lang=\"und\" dir=\"ltr\"><a href=\"https://t.co/C6x4eJxbOM\">https://t.co/C6x4eJxbOM</a> <a href=\"https://t.co/4K0XiH2kX2\">pic.twitter.com/4K0XiH2kX2</a></p>&mdash; not Jony Ive (@JonyIveParody) <a href=\"https://twitter.com/JonyIveParody/status/896027465889587200\">2017年8月11日</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n```\n\n#### Hexo-Twitter 插件方式\n\n安装插件：[Hexo-Twitter](https://github.com/tea3/hexo-tag-twitter)\n按如下方式应用推文\n\n```\n{% twitter tweet-url %}\n```\n\n两种方式使用效果一致:\n```\n{% twitter https://twitter.com/JonyIveParody/status/896027465889587200 %}\n```\n\n### 插入 Instagram\n\n#### 使用 Instagram 提供的内嵌\n\n要分享的帖子的页面 -> 右下角更多 -> 内嵌 -> 复制嵌入码 -> 粘贴嵌入码\n\n#### 使用 Hexo-Instagram 插件\n\n安装 [Hexo-Instagram 插件](https://github.com/tea3/hexo-tag-instagram)\n\n再使用以下方式插入：\n\n``` html\n{% instagram post-url %}\n```\n\n除了使用要插入的页面的 URL 作为`post-url`之外，还可以使用 URL 中独特的那几个奇奇特特的代码作为`post-url`。\n\n两种方式效果都一样，如下：\n\n```\n{% instagram 3LcFY5Niia %}\n```\n\n## 总结及注意事项\n\n总结起来基本就是有两种方法，\n\n1. 使用网站提供的内嵌方式，一般社交网站都会提供内嵌的的代码\n2. 使用 Hexo 插件\n\n一般来说使用插件会更加简单直观，在插入之前不妨搜一搜是否有对应的插件，要是没有再考虑社交网站提供的方式。\n\n比如 Vimeo, SoundCloud 等都是可以引用的。\n\n还有一个注意事项就是，要是你的博客开启了`Https`，而你要插入的内容却不是`Https`的，这样情况下，Chrome 会为了安全考虑而不会显示你插入的内容。\n","tags":["Hexo"]},{"title":" Hexo 折腾手记其二：编辑器增强及推荐插件","url":"/posts/31930/","content":"## 编辑器增强\n\n### Pull Quote 引用\n\n``` html\n{% pullquote [class] %}\ncontent\n{% endpullquote %}\n```\n\nclass 可为 right 或 left。记得去掉中括号。\n\n效果：\n\n\n{% pullquote right %}\n张岱（1597年－1679年），明末清初散文家，字宗子(呼应其岱，泰山，五岳之宗)，又字石公，号陶庵，别号蝶庵居士，山阴（今浙江绍兴）人。\n{% endpullquote %}\n\n崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。\n\n是日，更定矣，余拏一小舟，拥毳衣、炉火，独往湖心亭看雪。雾凇沆砀，天与云、与山、与水，上下一白。湖上影子，惟长堤一痕、湖心亭一点，与余舟一芥，舟中人两三粒而已。\n\n到亭上，有两人铺毡对坐，一童子烧酒，炉正沸。见余大喜，曰：“湖中焉得更有此人！”拉余同饮，余强饮三大白而别。问其姓氏，是金陵人，客此。\n\n及下船，舟子喃喃曰：“莫说相公痴，更有痴似相公者。\n\n\n### 多形式引用\n\n更多形式的引用参看官网文档，[Hexo - 标签插件](https://hexo.io/zh-cn/docs/tag-plugins.html#Pull-Quote)。\n\n也可看此处的[效果示范](https://probberechts.github.io/cactus-dark/2013/12/25/tag-plugins/)。\n\n\n### 显示拼音或日文假名\n\n按照这样的模版配置就好。\n\n``` html\n<span lang='ja'><ruby>作画<rp>（</rp><rt>さくが</rt><rp>）</rp></ruby></sapn>\n```\n\n显示效果：<span lang='ja'><ruby><rb>作画</rb><rp>（</rp><rt>さくが</rt><rp>）</rp></ruby>\n\n段落显示效果如下：\n\n> <span lang='ja'><ruby>暦<rp>（</rp><rt>こよみ</rt><rp>）</rp></ruby>の上に春は立ちながら厳しい寒さが続いておりますがいかがお過ごしですか？風邪などひいていませんか？<ruby>霜焼<rp>（</rp><rt>しもや</rt><rp>）</rp></ruby>けなどしていませんか？突然の手紙ごめんなさい。まだまだ寒く長い夜のついでに目を通していただければ<ruby>幸<rp>（</rp><rt>さいわ</rt><rp>）</rp></ruby>いです。</span>[^1]\n\n\n### 插入尾注\n\n安装[Hexo-Reference](https://github.com/quentin-chen/hexo-reference)插件，\n\n使用方式：\n\n![](1-44384d5ad58371dfa0524d7597f1ce5c.jpg)\n\n使用效果可见上一段的尾注效果。\n\n值得注意的是，在尾注里可以使用很多其他 Markdown 的效果，包括超链接，加粗等等。\n\n还有一点就是这个尾注不能加在小标题上，不然渲染时会报错。\n\n## 推荐插件\n\n这些插件都可以自行选择采用：\n\n博客加密：[hexo-blog-encrypt](https://github.com/MikeCoder/hexo-blog-encrypt)\n\n自动生成RSS：[hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)\n\n网页插入PDF：[hexo-pdf](https://github.com/superalsrk/hexo-pdf)\n\n自动生成站点地图：[hexo-generator-sitemap](https://github.com/hexojs/hexo-generator-sitemap)\n\nTHML, CSS, JS, 图片优化：[hexo-all-minifier](https://github.com/chenzhutian/hexo-all-minifier)\n\n为文章生成唯一的链接，方便搜索引擎抓取：[hexo-abbrlink](https://github.com/rozbo/hexo-abbrlink)。不过在使用这个插件时，千万不要在`hexo server`下直接更改 Markdown 文件名，不然会导致文件空白。\n\n\n[^1]: [最完美的离婚——光生给结夏的信](https://www.bilibili.com/video/av2209482/)","tags":["Hexo"]},{"title":"Hexo 折腾手记其一：使用 Adobe Typekit 云字体 (Web Font)","url":"/posts/37189/","content":"\n## 为什么选择使用云字体（Web font）？\n\n使用云字体可以保证博客在任何设备上的显示字体的统一性，缺点就是加载会稍微慢一些。由于 Google Font 在大陆地区访问困难，所以可以选择 Adobe Typekit 云字体。免费的 Adobe Typekit 账户可以添加两个字体，每月页面渲染册数 25,000 次，虽然不多，但作为个人博客用户也足够了。\n\n\n## 配置方法及步骤\n\n注册 Adobe 账户（如果没有的话） -> 登录 [Adobe Typekit](https://typekit.com) -> 选择右上角 Kits \n\n![](1-98fc016191d96521135e98d992d89c17.jpg)\n\n -> 创建新的 Kit -> 填好 Kit 的名字和你的博客域名（建议将`local`也填上） -> 切换到 Adobe Typekit[字体选择页面](https://typekit.com/fonts) -> 分别搜索`Source Han Serif Simplified Chinese`（思源宋简体）和`Source Han Sans Simplified Chinese`（思源黑简体） -> 并将两个都添加至之前所新建的 Kit 当中（确认 Character Set 为 Dynamic Subsetting） -> 在右上角 Kits 中选择你新建的 Kit 进入 Kit 编辑页面 -> 在左侧区域选择字重(建议选择一个字体就行，字重不要超过三个)\n\n![字重选择](2-f8c6b7cc458513a49726e41bbbf577d3-51b6202d34abbd21b7d054e342bdfcc3.jpg)\n\n -> 右下角点`Publish` -> 右上角点`Embed Code` -> 复制出现的代码\n\n![复制框选的代码](3.jpg)\n\n -> 将其粘贴到`主题文件夹\\layout\\_partial\\head.ejs`文件中，位置见图\n\n![粘贴的位置](4-dd17db82384c624f1ba512f698975749.jpg)\n\n -> 编辑`主题文件夹\\source\\css\\_variables.styl`文件 -> `source-han-serif-sc`（思源宋）或者`source-han-sans-simplified-c`（思源黑）粘贴在`$font-family-body = `后面（就在第一行附近），也可以更改顺序（如果你知道你在做什么） -> 最后再重新编译发布就好了\n\n## 关于字体和字重的选择\n\n关于字体的选择：Adobe Typekit 中能用的、好用的中文字体也就只有思源黑、思源宋这两个了，建议选择思源黑，因为在大多数 Windows 电脑上，宋体的渲染结果都很辣眼睛。\n\n关于字重的选择：字重选择越多，页面所要加载的文件也就越大，加载速也就越慢，建议不要超过三个，一般包括常规体和粗体就行了。\n\n\n本文参考了[Hexo Theme - Using Ubuntu Google Fonts](http://jr0cket.co.uk/2014/06/hexo-theme-using-ubuntu-google-fonts.html).","tags":["Hexo","字体"]},{"title":"关于白夜行中某些隐藏剧情的推断","url":"/posts/37332/","content":"\n> **本文严重剧透以及长难句预警**\n> **内容相当相当粗俗，小孩子还请自觉回避**\n\n![](白夜行-e47cf01d30ed86607339a91c6123f8c6.jpg)\n\n## 亮司不能射精的原因\n\n一开始我还以为是亮司答应帮助友彦洗脱嫌疑，强行与尸体发生性关系后被恶心到了，留下了心理阴影所以性功能出现障碍，心想这亮司也不是铁板一块啊。后来觉得这个时间点不对，还可以提前。引起我注意的是那晚奈美江（后来成为亮司公司的会计）回去拿手表时亮司做出的疯狂举动：亮司被嘲讽做爱时间短后显得非常暴躁并做出了性暴露狂的行为，这并不能简单的理解为青春期少年对性事的敏感和冲动，亮司一直以来就是一个冷静且缺乏情绪流露的一个人，这次的反应如此之大，只能归因于奈美江无意中碰到了亮司的痛点：亮司不是做爱时间短，而是时间太长（不能射精）。性暴露的行为也可以作为一个佐证，很多暴露狂都因为在性行为上存在一定程度上的心理或者生理障碍而变得性格畸形，急于想证明自己。（看美剧瞎猜的理论）后来再次翻书得到了印证，书中原文：「有本事就让它射啊！」。\n\n那么在这个时候，亮司焦虑的原因是什么？没意识到自己不能射精的原因？但是在答应帮忙友彦的时候又显得非常有计划，他应该是知道有个人是能让他射精的，当然这个人就是雪穗。我的一个不负责任的猜测是说不定亮司这时候对雪穗是存在抵触甚至反抗情绪，但是为了救友彦，他还是屈服了。当然可能还有其他猜测，我的猜测也算不上是合理。\n\n这样的话，尸体里面的精液毫无疑问是雪穗帮了忙，后面亮司的情人典子（药剂师）的猜测也呼应了这一点。典子用手的那一次亮司心里想的说不定还是雪穗帮他的那一次，为什么这一次的印象这么深刻呢？亮司与雪穗之间的性行为其实并不频繁？（我自己也觉得这个猜测挺牵强的）\n\n亮司可能从一开始就存在性功能障碍，心理创伤来自于小时候目睹的暴行，想必是多么的残忍。\n\n\n## 雪穗的第三次「偷走他人的灵魂」\n\n「偷走他人的灵魂」这种行为当然指的就是亮司对他人实施性侵犯，然后雪穗做第一个目击者，以共同保守秘密为由，来达到自己的目的。总共有三次，第一次在雪穗初中时，为的是封口；第二次在大学时，为的是嫉妒；第三次的受害者是雪穗第二任丈夫的女儿，为的是获得亲密关系。第三次与前两次最大的不同在于第三次的强奸过程发生了插入过程，而前两次并没有，书中给了足够的暗示（「下腹部残留的闷痛」）来暗示第三次与前两次的不同。为什么第三次要如此的伤害一个不相干的人，（当然前两次也是很大的伤害，但这一次的伤害更无情）从目的和结果来看完全没必要，我能想到的有以下两种解释：\n\n* 第三次的施暴人并不是亮司，而是另一个更残暴或不受控制的一个人。但我觉得这种解释的可能性极小。\n\n* 雪穗这一次如此残暴的原因是来自她心理的畸变：她已不能再生育。书里给了足够的暗示：雪穗第一任丈夫的第二任妻子已经怀孕。不能生育的原因来自她小时候遭受到的暴行，雪穗也意识到了这一点。处于嫉妒或者纯粹变态，她在知道自己所做的事情可能导致的永久伤害的情况下，还是施加了暴行，怎么讲，这个人已经没法洗白了。\n\n\n## 推理的焦点\n\n《白夜行》在叙事方式上很反常规，给了足够的配角POV描写，唯独缺乏主角的第一视角描写。我们对主角的所有印象都是来自于其他人的视角。事实上，我们对主角知之甚少。随着故事的不断发展，也能猜到凶手是谁，作为一个推理小说，推理的结果已经知道了，完成凶案过程推理的关键要素也到故事的后半部分才浮出水面，似乎没剩下多少推理的乐趣。\n\n但如果把推理的焦点从犯罪本身转移到人身上，在蛛丝马迹中追随主角的脚步，推导主角所经历的一切以及心境的变化，想想就觉得刺激。不过能够推理的材料也不多，男女主除了在点题环节有过直接的情感表露之外，还有一两次的情绪失控，很难从中窥伺出内心所想。\n\n其中最难把握的就是男女主角之间的关系了，除了像老警察所说的那样「共生」之外，还有更深层次的关系吗？不要被点题环节的情感流露所迷惑，他俩之间的关系似乎显得残酷的多。究竟这之间经历了怎样的变化？\n\n值得注意的一点是，我们所有的这些颅内猫鼠游戏的全部材料来源都只是那本书，只是文本，而不是什么客观事实、犯罪现场。所以，文本作者的意图的显得非常重要，我们都是在作者的不断强调和暗示下，追逐着那跳动的影子。想想作者想告诉我们什么，揣摩作者的思路，说不定会有一些发现。\n\n我只想出了以上两个我觉得有意思的点，搜索后也发现另一个人找到了些其他有意思的地方，请移步[那些隱去的事情](https://book.douban.com/review/6284211/)。如果有更多的隐藏剧情或者对本文有任何批评建议，欢迎探讨交流。","tags":["书"]},{"title":"特师文集","url":"/posts/54430/","content":"\n想要拜读大咕咕咕鸡的魔幻主义大作而又没有系统的收录比较全的文集，恰好自己有闲时，就做了这么一个开创性工作。\n\n根据豆瓣[人间动物园](https://www.douban.com/group/mindfucking/)小组里各位锤粉的搬运和[ Readlists ](http://readlists.com/)的自动抓取，epub打包下载。然后自己手动统一格式，做目录，就做出了这么一个张大锤文集出来，大概有一百篇左右吧，长文、短诗都有。\n\n有需要的人自取吧，链接:[百度云](https://pan.baidu.com/s/1jGH5Ah4) 密码: vwpm\n\n希望分享的人尽量低调一些吧，尽量私下分享，毕竟我以前在微博上公开分享被豆瓣阅读的人盯上了，说他们已经买了版权了，可大半年了，官方的文集也没出来。\n\n感谢人间动物园的各位锤粉的搬运。\n\n就做了这么一些微小的工作，谢谢大家。\n\n2015年9月30号   凌晨0:02","tags":["杂"]},{"title":"关于《蛤蟆的油》","url":"/posts/32259/","content":"\n日本民间流传着一种蛤蟆，外表奇丑，平时自己察觉不到，但人把镜子放到它面前后，蛤蟆看到自己丑陋的外表之后吓出一身油，这种油是一种治疗烫伤的珍贵药材。当黑泽明将自己的内心剖析给大家看的时候，于是就有了这本书。\n\n老头子真是一个真诚而有趣的人啊，前三章是在讲黑泽明在当导演之前的生活经历，后三章讲的是正式步入电影行业之后，从副导演一直攀爬高山，直到导演了罗生门之后的事。文章写得很有趣，有些地方看的会让人忍俊不禁，导演也是个真性情的人，是看的不多的极其有趣轻松的书。\n\n提到黑泽明在一生中遇到的几位及其重要的导师的时候他都是及其尊敬的，尤其是对于他在电影事业上有非常重要的帮助的山本嘉次郎导演。提到他和他基友合作的作品上映后小学老师与他们的重逢，这股人亲味是让我最为感动的。他那位初中老师对于操行分的看法也是搞笑的。\n\n与基友植草圭之助之间的「爱恨情仇」也是贯穿黑泽明生命的。在「人非强者」一节中，人称「电影天皇」的黑泽明也诚恳的说自己是一个为了抵抗人的苦恼而戴上强者面的弱者呢。哈哈，可惜书只写到拍《罗生门》，真是想看看黑泽明对于之后他与三船敏郎之间的恩怨大八卦呢。\n\n黑泽明对于日本战时的审查制度的厌恶也表现的毫不掩饰。对于审查制度，《笑之大学》里描述了很多。那就是一群猥琐不堪的人，任何一点东西都能激起他们的往性上面的联想。「直到现在我还感谢小津先生，也因没砸那家伙而感到遗憾。」哈哈哈\n\n尝试写书评，但真的好难啊，大概只能记成流水账了。\n\n2015年7月10日星期五   凌晨1:37  室友都还在打游戏","tags":["书"]},{"title":"如何评价 IPN 出品的《無次元》节目？","url":"/posts/31171/","content":"\n我觉得《無次元》既然是一个有关于声音的，又带有强烈的实验艺术特征的博客，我们不妨把关键词放到「艺术」二字上。\n\n最近重新看了一遍《谈美》，有一些话让我印象很深。一直在脑海里回响的是这样一句话：\n>美感经验是直觉的而不是反省的。\n\n或许，我们在欣赏《無次元》的时候应该考虑的就是这样的「直觉经验」。就像欣赏其他的艺术类型一样。\n\n普通人不懂色彩理论，不懂绘图结构，但是这并不妨碍我们走进美术馆去转一转，或许就能找到那一幅让你驻足良久的画呢？\n\n普通人不懂诗歌结构，不懂意象的运用，但是击中心灵让人泪流满面的诗比比皆是。\n\n我想，作为一个具有移情作用的非仿生人，我们是能够共享一些情感的，这些情感正是我们与作品之间交流的桥梁。也是不同艺术形式存在的基础。\n\n在《無次元》第一期的时候，想想「The People United Will Never Be Defeated!」虽然身隔千里，不过我们还是被那样的热血所感染。\n\n播客是一种媒介，而《無次元》正在尝试将它作为一个艺术形式。\n\n所以，不妨用欣赏艺术的眼光去看待《無次元》。\n\n就像其他艺术类型一样，同一期节目，每个人的感受并非完全一致。就像「她_的时候总要显形 [Playback Unit]」这期节目中，我的感觉很亲切，反复回到了初中毕业后的那个暑假，见到了好多老同学，和他们一起吐槽这个漫长的夏天。而我基友却觉得后背发麻。\n\n虽然「直觉经验」在欣赏艺术的时候起了很大作用，但艺术欣赏并非完全的没有门槛。只有在接受欣赏艺术的教育之后才能感受到更高级的美感经验。这也是普通听众与《無次元》最大的距离吧。对具有强烈情感倾向的节目很有体会，觉得自己听懂了，对于其他节目就会一头雾水，不知所云。\n\n这样的「直觉经验」才是最大的湿货吧。\n\n《無次元》在做艺术尝试的同时还要加上显著的<b>实验</b>二字，甚至<b>实验</b>是《無次元》的灵魂。所以《無次元》在形式的表现上会更加多元化，更加非常规。但是关于实验艺术的事情我并不了解，就不多说了。\n\n一直很喜欢《無次元》，最近不知道为什么好久没更新了，甚为遗憾。\n\n看到李如一老师给这个问题下的每个回答都点了赞同，这种做法还蛮《無次元》的。其实我也是来想骗个赞的。\n\n关于艺术一些自己的小看法，很幼稚，还请诸位多多见谅。\n\n以上。\n\n知乎回答地址：http://www.zhihu.com/question/27143033/answer/41848323\n\n2015年3月13  星期五  凌晨0：30\n\n回答被無次元推荐了，简直不能太开心！\n\n![](1.jpg)\n\n2015年3月20 星期五 晚上20：21","tags":["杂"]},{"title":"关于《柯 P 新政》","url":"/posts/11378/","content":"\n前几天台湾的九合一选举在大陆火了一把，特别是国民党的溃败更使得其话题性大大增加，新浪新闻也做了好几个专题来介绍这次的「华人地区最大的选举」，其中的台北市长选举最为受人瞩目，在这之间，国民党的「官二代」连胜文与以「超越蓝绿」为口号的无党派柯文哲之间的竞争最为激烈。\n\n昨天刚在推特上有人转发了GitBook上的柯文哲的施政计划书——《柯P新政》。听起来有点意思，于是就在上面下载了PDF文件阅读，一点想法，权当读后感记下来好了。\n\n###  何为GitBook？\n\n了解GitBook之前不得不了解何为Git，[Git](http://zh.wikipedia.org/wiki/Git)原为一种代码版本控制工具，是为更好的管理Linux内核开发而设计。依据Git理念建立的在线代码托管网站[GitHub](www.github.com)也是程序员最喜欢的开源代码交流平台。\n\n顾名思义，GitBook是将编程界的Git理念运用于写作。不同于传统的写作模式，GitBook上的书的创作过程中就全部公开，读者在见证书的创作过程中也可以评论，作者可以很好的收到读者的反馈来调整书的写作。同时由于借鉴了版本控制的理念，创作模式上的改变也对多人协同创作提供了更为方便的管理。\n\n将施政纲领放到GitBook上也是一个很新的尝试。施政纲领阐述了对现阶段的社会状况的认识，指出社会症结所在，提出未来的解决办法，是对参选人参政理念一个完整的阐述。所以，在传统的认识上，这是一类比较严谨的文件。但从效果上来看，这是一个很不错的尝试，每一章节的阅读页面下有很多人的积极参与评论，有赞同，也有指出不足的，好的建议会被大家**「赞」**起来让更多人看到，这对普及施政理念，提高网民参与政治的积极性也是一件很好的举措。\n\n花了一个晚上的时间通读了整个的《柯P新政》，提取出几个关键词来以我的方式来解读一下，算是开始正式的读后感。\n\n###  关键词一：拥抱技术\n\n互联网的发展，特别是近几年的社交网络，新媒体及移动互联网的发展，深刻的改变着信息流通的方式，如果反应不够及时，不能正确的适应好新浪潮下的姿态，就很容易处于不利的地位。推荐一篇[文章](http://www.hungry.tw/2014/11/2008-2014.html)，可以看看台湾人关于Fcebook对马英九的政治影响的观点。\n\n同时争取「年轻的一代」是选举中经常出现的一个政策，而社交网络和移动互联网正是年轻人甚至是当代社会一个很明显的特征。\n\n很让人兴奋的是，从《柯P新政》中可以看出，柯文哲团队对「时代特征」是持相当拥抱的程度。新的I-Voting计划，旨在将选举站搬到手机上，在手机上就可以投票，同时透过手机可直接参与对政府官员的年终的考核，不让选举成为一个一次性的事情。\n\n在发展台北旅游业的「ABC」计划的「A」指的就是App，开发出专用的旅游移动App来指导自助游，鼓励自助游积极探索台北。\n\n不仅仅如此，柯文哲团队在更多技术方面所走的深度和眼见得高度更是让我感到吃惊。\n数据挖掘(Data Mining)或大数据(Big Data)对于经常关注科技行业的人来说是不是一个新鲜概念，但是在施政纲领上一直提到這一点，还是很让人感到兴奋的。\n\n不仅在保证隐私的前提上采集数据，还承诺开放数据供开发者使用，旨在通过搭建平台的方式来改善市民的生活质量。\n比如在公交车改革中，利用市民出行数据的分析线路来精简公交车数量，或者来增开人流量多的线路。在医疗改革中的关于建设个人医疗档案中一项，这些也是医疗信息化改革中很直接的实践。\n\n还有对移动支付的支持，柯文哲承诺未来的台北，公交，购物都将支持手机支付。\n之前一直在《IT公论》中经常听到关于这些新技术的动态和讨论，但是一直以为这只是未来而已，但现在看到一个竞选者这麽积极的推动新技术的实践，未来正在慢慢的成为现实，想想就有点小激动。\n\n都说柯文哲是一个中年人，但是代表着年轻人。毫不客气的讲，看到这种对技术的热衷，有一种很亲切的感觉。这是一个数字空间的原住民所希望的生活的城市。\n\n当然从技术概念到实践是困难重重的，也祝福台北能取得很好的成绩。\n\n###  关键词二：政府的责任\n\n在李总理上台的时候，就一直在强调政府改革，其中的一个方向就是「小政府」，虽然现在也不知道实行得怎么样了。大陆的政府也经常被批评管的太多以至于臃肿不堪，要求政府放手来让市场「看不见的手」来调节的声音一直不绝于耳。但是这次在台北却有着不一样的声音，《柯P新政》里经常强调的一点就是政府要承担起政府的责任。\n\n大政府也有大政府的好，政府有能力来集中力量来做大事。比如说新建公共住宅来缓解住宅的问题，通过政府征地，政府向银行借贷，甚至事后物业也是政府来包办。\n\n还有一点就是加强政府对市场的干预，关于台北地区的路不平的问题，原因在于建设需要，道路经常反复挖掘，而各个建设公司又没有同一的协调。新政策的解决办法就是对需要对道路改造时需要一个统一的时间来改造，减少挖掘的次数。\n\n大政府与小政府的矛盾体验同样体现在都市更新上。台北旧的都市更新政策把都市更新任务完全交给了住户和建商，政策失败之处就是过于相信市场，而市场自由其软弱之处，有时候需要政府的干预才能推动事情的发展。柯文哲主张政府应该出面拟定统一的计划来逐步进行都市更新，政府的获得的公共用地则用来新建公共设施和保障贫困户的居住，政府还可以与开发商进行协调，提供给住户不同的建房选择，是旧屋改建抑或是易地更换新屋。\n\n這就是一直强调的政府的责任。\n\n###  关键词三：塑造城市的权利\n\n> 享受城市的權利不僅僅是在城市中獲得生活所需的空間， 還包括參與城市生活的權利、 平等使用城市的權利、 塑造城市的權利。\n\n塑造城市的权利，这是一个很棒的观点，看一下柯文哲的主张是如何体现這一理念的。\n\n第一个是参与式预算。将政府的预算公布到网上，市民可以用手机来投票决定不必要的预算，并将這一笔省下的钱用来提议建设新的项目，同样也是投票来决定新的项目。这样情况下，城市的直接决策权就有一部分交到了普通市民的手中，塑造城市的权利得到体现。\n\n第二个是文化自治。\n\n> 決策及資源運用則交還給專業的文化人士。\n\n \n政府官员退出对文化领域的干预，文化局长由各文化团体推举，并且提升文化局长的权利，文化局长将是整个城市的文化建设的决定人。\n\n第三个是田园城市。\n\n>「這是一個失落新世代： 我們的孩子不會煮飯、 不曉得食物怎麼來的， 更不知道如何吃得健康。 」\n> —— 傑米． 奧利佛， 英國名廚師\n\n  \n> 透過微型田園、 人行田道、 街角田地、 垂直種植來擴張台北市的田園版圖，\n\n将城市绿化景观改造成「可以吃的地景」，追求人性化，乡村化，田园化的城市。通过小型化微型田园来保留人对自然的亲切感，对季节的熟悉感，获得绿色食材的同时还能让下一代与自然重新连结。这是我个人很喜欢的一个主张，牺牲统一的美感，自己参与建设之中，吃自己播种的蔬菜，想想就情怀指数暴表。不过平心而论，这个政策也是蛮有争议的，毕竟不是所有人都喜欢与泥巴打交道吧。\n\n重新修改的时候，已经据初稿有了一个月了，这一个月里面，柯文哲也已经上任，风风火火的在推行他的新政，同时也在经受质疑。我就当一个旁观者默默的观察吧，看如何「改變臺灣，從臺北開始」。\n\n看《柯P新政》是一时性起，但是写了这篇文章还是花了不少时间的，主要还是自己的效率太低了，写了权当一个消遣吧。\n\n我知道政治家的话都不能轻信，我知道政客是如何千方百计讨好选民，所以这份警惕之心还是有的。不过另一方面也倒是还挺羡慕的，说不定要是在台北我也还有用武之地呢（笑 。\n\n以上。\n\n初稿于2014年12月9日星期二       凌晨1：32\n再稿于2015年1月7日星期三         凌晨0：39","tags":["政"]},{"url":"/googled42d74cff817ade6.html","content":"google-site-verification: googled42d74cff817ade6.html"},{"title":"about","url":"/about/index.html","content":"\n{% blockquote 原一男 %} 「永远激进 永远自由」 {% endblockquote %}\n"},{"title":"search","url":"/search/index.html"}]